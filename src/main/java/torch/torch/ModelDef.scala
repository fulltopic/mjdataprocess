// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package torch.torch

/** @param protoVersion
  *   for the proto version, to keep both backward and forward
  *   compatibility, please bump the proto_version when we add any
  *   change in the proto. runtime decides whether accept the
  *   model based on the ir_version.
  * @param mainModule
  *   main module of the model
  * @param producerName
  *   to distinguish whether exported from c2 or torch
  * @param producerVersion
  *   put build version here
  * @param tensors
  *   the table contains all the tensor information
  *   the tensor id is defined as TensorProto.name
  */
@SerialVersionUID(0L)
final case class ModelDef(
    protoVersion: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
    mainModule: _root_.scala.Option[torch.torch.ModuleDef] = _root_.scala.None,
    producerName: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    producerVersion: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    tensors: _root_.scala.Seq[torch.torch.TensorDef] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ModelDef] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (protoVersion.isDefined) {
        val __value = protoVersion.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(1, __value)
      };
      if (mainModule.isDefined) {
        val __value = mainModule.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (producerName.isDefined) {
        val __value = producerName.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
      };
      if (producerVersion.isDefined) {
        val __value = producerVersion.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(4, __value)
      };
      tensors.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      protoVersion.foreach { __v =>
        val __m = __v
        _output__.writeInt64(1, __m)
      };
      mainModule.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      producerName.foreach { __v =>
        val __m = __v
        _output__.writeString(3, __m)
      };
      producerVersion.foreach { __v =>
        val __m = __v
        _output__.writeString(4, __m)
      };
      tensors.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getProtoVersion: _root_.scala.Long = protoVersion.getOrElse(0L)
    def clearProtoVersion: ModelDef = copy(protoVersion = _root_.scala.None)
    def withProtoVersion(__v: _root_.scala.Long): ModelDef = copy(protoVersion = Option(__v))
    def getMainModule: torch.torch.ModuleDef = mainModule.getOrElse(torch.torch.ModuleDef.defaultInstance)
    def clearMainModule: ModelDef = copy(mainModule = _root_.scala.None)
    def withMainModule(__v: torch.torch.ModuleDef): ModelDef = copy(mainModule = Option(__v))
    def getProducerName: _root_.scala.Predef.String = producerName.getOrElse("")
    def clearProducerName: ModelDef = copy(producerName = _root_.scala.None)
    def withProducerName(__v: _root_.scala.Predef.String): ModelDef = copy(producerName = Option(__v))
    def getProducerVersion: _root_.scala.Predef.String = producerVersion.getOrElse("")
    def clearProducerVersion: ModelDef = copy(producerVersion = _root_.scala.None)
    def withProducerVersion(__v: _root_.scala.Predef.String): ModelDef = copy(producerVersion = Option(__v))
    def clearTensors = copy(tensors = _root_.scala.Seq.empty)
    def addTensors(__vs: torch.torch.TensorDef*): ModelDef = addAllTensors(__vs)
    def addAllTensors(__vs: Iterable[torch.torch.TensorDef]): ModelDef = copy(tensors = tensors ++ __vs)
    def withTensors(__v: _root_.scala.Seq[torch.torch.TensorDef]): ModelDef = copy(tensors = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => protoVersion.orNull
        case 2 => mainModule.orNull
        case 3 => producerName.orNull
        case 4 => producerVersion.orNull
        case 5 => tensors
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => protoVersion.map(_root_.scalapb.descriptors.PLong(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => mainModule.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => producerName.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => producerVersion.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => _root_.scalapb.descriptors.PRepeated(tensors.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = torch.torch.ModelDef
    // @@protoc_insertion_point(GeneratedMessage[torch.ModelDef])
}

object ModelDef extends scalapb.GeneratedMessageCompanion[torch.torch.ModelDef] with scalapb.HasBuilder[torch.torch.ModelDef] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[torch.torch.ModelDef] with scalapb.HasBuilder[torch.torch.ModelDef] = this
  def merge(`_message__`: torch.torch.ModelDef, `_input__`: _root_.com.google.protobuf.CodedInputStream): torch.torch.ModelDef = newBuilder(_message__).merge(_input__).result()
  implicit def messageReads: _root_.scalapb.descriptors.Reads[torch.torch.ModelDef] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      torch.torch.ModelDef(
        protoVersion = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]]),
        mainModule = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[torch.torch.ModuleDef]]),
        producerName = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        producerVersion = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        tensors = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Seq[torch.torch.TensorDef]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = TorchProto.javaDescriptor.getMessageTypes().get(6)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = TorchProto.scalaDescriptor.messages(6)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = torch.torch.ModuleDef
      case 5 => __out = torch.torch.TensorDef
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = torch.torch.ModelDef(
    protoVersion = _root_.scala.None,
    mainModule = _root_.scala.None,
    producerName = _root_.scala.None,
    producerVersion = _root_.scala.None,
    tensors = _root_.scala.Seq.empty
  )
  final class Builder private (
    private var __protoVersion: _root_.scala.Option[_root_.scala.Long],
    private var __mainModule: _root_.scala.Option[torch.torch.ModuleDef],
    private var __producerName: _root_.scala.Option[_root_.scala.Predef.String],
    private var __producerVersion: _root_.scala.Option[_root_.scala.Predef.String],
    private val __tensors: _root_.scala.collection.immutable.VectorBuilder[torch.torch.TensorDef],
    private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
  ) extends _root_.scalapb.MessageBuilder[torch.torch.ModelDef] {
    def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __protoVersion = Option(_input__.readInt64())
          case 18 =>
            __mainModule = Option(__mainModule.fold(_root_.scalapb.LiteParser.readMessage[torch.torch.ModuleDef](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 26 =>
            __producerName = Option(_input__.readStringRequireUtf8())
          case 34 =>
            __producerVersion = Option(_input__.readStringRequireUtf8())
          case 42 =>
            __tensors += _root_.scalapb.LiteParser.readMessage[torch.torch.TensorDef](_input__)
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      this
    }
    def result(): torch.torch.ModelDef = {
      torch.torch.ModelDef(
        protoVersion = __protoVersion,
        mainModule = __mainModule,
        producerName = __producerName,
        producerVersion = __producerVersion,
        tensors = __tensors.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
  }
  object Builder extends _root_.scalapb.MessageBuilderCompanion[torch.torch.ModelDef, torch.torch.ModelDef.Builder] {
    def apply(): Builder = new Builder(
      __protoVersion = _root_.scala.None,
      __mainModule = _root_.scala.None,
      __producerName = _root_.scala.None,
      __producerVersion = _root_.scala.None,
      __tensors = new _root_.scala.collection.immutable.VectorBuilder[torch.torch.TensorDef],
      `_unknownFields__` = null
    )
    def apply(`_message__`: torch.torch.ModelDef): Builder = new Builder(
        __protoVersion = _message__.protoVersion,
        __mainModule = _message__.mainModule,
        __producerName = _message__.producerName,
        __producerVersion = _message__.producerVersion,
        __tensors = new _root_.scala.collection.immutable.VectorBuilder[torch.torch.TensorDef] ++= _message__.tensors,
        `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
    )
  }
  def newBuilder: Builder = torch.torch.ModelDef.Builder()
  def newBuilder(`_message__`: torch.torch.ModelDef): Builder = torch.torch.ModelDef.Builder(_message__)
  implicit class ModelDefLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, torch.torch.ModelDef]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, torch.torch.ModelDef](_l) {
    def protoVersion: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getProtoVersion)((c_, f_) => c_.copy(protoVersion = Option(f_)))
    def optionalProtoVersion: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.protoVersion)((c_, f_) => c_.copy(protoVersion = f_))
    def mainModule: _root_.scalapb.lenses.Lens[UpperPB, torch.torch.ModuleDef] = field(_.getMainModule)((c_, f_) => c_.copy(mainModule = Option(f_)))
    def optionalMainModule: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[torch.torch.ModuleDef]] = field(_.mainModule)((c_, f_) => c_.copy(mainModule = f_))
    def producerName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getProducerName)((c_, f_) => c_.copy(producerName = Option(f_)))
    def optionalProducerName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.producerName)((c_, f_) => c_.copy(producerName = f_))
    def producerVersion: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getProducerVersion)((c_, f_) => c_.copy(producerVersion = Option(f_)))
    def optionalProducerVersion: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.producerVersion)((c_, f_) => c_.copy(producerVersion = f_))
    def tensors: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[torch.torch.TensorDef]] = field(_.tensors)((c_, f_) => c_.copy(tensors = f_))
  }
  final val PROTO_VERSION_FIELD_NUMBER = 1
  final val MAIN_MODULE_FIELD_NUMBER = 2
  final val PRODUCER_NAME_FIELD_NUMBER = 3
  final val PRODUCER_VERSION_FIELD_NUMBER = 4
  final val TENSORS_FIELD_NUMBER = 5
  def of(
    protoVersion: _root_.scala.Option[_root_.scala.Long],
    mainModule: _root_.scala.Option[torch.torch.ModuleDef],
    producerName: _root_.scala.Option[_root_.scala.Predef.String],
    producerVersion: _root_.scala.Option[_root_.scala.Predef.String],
    tensors: _root_.scala.Seq[torch.torch.TensorDef]
  ): _root_.torch.torch.ModelDef = _root_.torch.torch.ModelDef(
    protoVersion,
    mainModule,
    producerName,
    producerVersion,
    tensors
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[torch.ModelDef])
}
