// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package caffe2.caffe2

/** TensorProto stores serialized Tensor objects.
  *
  * @param dims
  *   The dimensions in the tensor.
  * @param floatData
  *   For float
  * @param int32Data
  *   For int32, uint8, int8, uint16, int16, bool, and float16
  *   Note about float16: in storage we will basically convert float16 byte-wise
  *   to unsigned short and then store them in the int32_data field.
  * @param byteData
  *   For bytes
  * @param stringData
  *   For strings
  * @param doubleData
  *   For double
  * @param int64Data
  *   For int64
  * @param rawData
  *   store the raw data, contents are serialized as little-endian
  * @param externalData
  *   store the pointer to the data
  * @param name
  *   Optionally, a name for the tensor.
  * @param deviceDetail
  *   Optionally, a TensorProto can contain the details about the device that
  *   it was serialized from. This is useful in cases like snapshotting a whole
  *   workspace in a multi-GPU environment.
  */
@SerialVersionUID(0L)
final case class TensorProto(
    dims: _root_.scala.Seq[_root_.scala.Long] = _root_.scala.Seq.empty,
    dataType: _root_.scala.Option[caffe2.caffe2.TensorProto.DataType] = _root_.scala.None,
    storageType: _root_.scala.Option[caffe2.caffe2.TensorProto.StorageType] = _root_.scala.None,
    floatData: _root_.scala.Seq[_root_.scala.Float] = _root_.scala.Seq.empty,
    int32Data: _root_.scala.Seq[_root_.scala.Int] = _root_.scala.Seq.empty,
    byteData: _root_.scala.Option[_root_.com.google.protobuf.ByteString] = _root_.scala.None,
    stringData: _root_.scala.Seq[_root_.com.google.protobuf.ByteString] = _root_.scala.Seq.empty,
    doubleData: _root_.scala.Seq[_root_.scala.Double] = _root_.scala.Seq.empty,
    int64Data: _root_.scala.Seq[_root_.scala.Long] = _root_.scala.Seq.empty,
    rawData: _root_.scala.Option[_root_.com.google.protobuf.ByteString] = _root_.scala.None,
    externalData: _root_.scala.Option[caffe2.caffe2.ExternalDataProto] = _root_.scala.None,
    name: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    deviceDetail: _root_.scala.Option[caffe2.caffe2.DeviceOption] = _root_.scala.None,
    segment: _root_.scala.Option[caffe2.caffe2.TensorProto.Segment] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[TensorProto] {
    private[this] def floatDataSerializedSize = {
      4 * floatData.size
    }
    private[this] def int32DataSerializedSize = {
      if (__int32DataSerializedSizeField == 0) __int32DataSerializedSizeField = {
        var __s: _root_.scala.Int = 0
        int32Data.foreach(__i => __s += _root_.com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(__i))
        __s
      }
      __int32DataSerializedSizeField
    }
    @transient private[this] var __int32DataSerializedSizeField: _root_.scala.Int = 0
    private[this] def doubleDataSerializedSize = {
      8 * doubleData.size
    }
    private[this] def int64DataSerializedSize = {
      if (__int64DataSerializedSizeField == 0) __int64DataSerializedSizeField = {
        var __s: _root_.scala.Int = 0
        int64Data.foreach(__i => __s += _root_.com.google.protobuf.CodedOutputStream.computeInt64SizeNoTag(__i))
        __s
      }
      __int64DataSerializedSizeField
    }
    @transient private[this] var __int64DataSerializedSizeField: _root_.scala.Int = 0
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      dims.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(1, __value)
      }
      if (dataType.isDefined) {
        val __value = dataType.get.value
        __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(2, __value)
      };
      if (storageType.isDefined) {
        val __value = storageType.get.value
        __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(12, __value)
      };
      if (floatData.nonEmpty) {
        val __localsize = floatDataSerializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__localsize) + __localsize
      }
      if (int32Data.nonEmpty) {
        val __localsize = int32DataSerializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__localsize) + __localsize
      }
      if (byteData.isDefined) {
        val __value = byteData.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(5, __value)
      };
      stringData.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(6, __value)
      }
      if (doubleData.nonEmpty) {
        val __localsize = doubleDataSerializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__localsize) + __localsize
      }
      if (int64Data.nonEmpty) {
        val __localsize = int64DataSerializedSize
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__localsize) + __localsize
      }
      if (rawData.isDefined) {
        val __value = rawData.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(13, __value)
      };
      if (externalData.isDefined) {
        val __value = externalData.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (name.isDefined) {
        val __value = name.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(7, __value)
      };
      if (deviceDetail.isDefined) {
        val __value = deviceDetail.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (segment.isDefined) {
        val __value = segment.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      dims.foreach { __v =>
        val __m = __v
        _output__.writeInt64(1, __m)
      };
      dataType.foreach { __v =>
        val __m = __v.value
        _output__.writeEnum(2, __m)
      };
      if (floatData.nonEmpty) {
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(floatDataSerializedSize)
        floatData.foreach(_output__.writeFloatNoTag)
      };
      if (int32Data.nonEmpty) {
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(int32DataSerializedSize)
        int32Data.foreach(_output__.writeInt32NoTag)
      };
      byteData.foreach { __v =>
        val __m = __v
        _output__.writeBytes(5, __m)
      };
      stringData.foreach { __v =>
        val __m = __v
        _output__.writeBytes(6, __m)
      };
      name.foreach { __v =>
        val __m = __v
        _output__.writeString(7, __m)
      };
      deviceDetail.foreach { __v =>
        val __m = __v
        _output__.writeTag(8, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      if (doubleData.nonEmpty) {
        _output__.writeTag(9, 2)
        _output__.writeUInt32NoTag(doubleDataSerializedSize)
        doubleData.foreach(_output__.writeDoubleNoTag)
      };
      if (int64Data.nonEmpty) {
        _output__.writeTag(10, 2)
        _output__.writeUInt32NoTag(int64DataSerializedSize)
        int64Data.foreach(_output__.writeInt64NoTag)
      };
      segment.foreach { __v =>
        val __m = __v
        _output__.writeTag(11, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      storageType.foreach { __v =>
        val __m = __v.value
        _output__.writeEnum(12, __m)
      };
      rawData.foreach { __v =>
        val __m = __v
        _output__.writeBytes(13, __m)
      };
      externalData.foreach { __v =>
        val __m = __v
        _output__.writeTag(14, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def clearDims = copy(dims = _root_.scala.Seq.empty)
    def addDims(__vs: _root_.scala.Long*): TensorProto = addAllDims(__vs)
    def addAllDims(__vs: Iterable[_root_.scala.Long]): TensorProto = copy(dims = dims ++ __vs)
    def withDims(__v: _root_.scala.Seq[_root_.scala.Long]): TensorProto = copy(dims = __v)
    def getDataType: caffe2.caffe2.TensorProto.DataType = dataType.getOrElse(caffe2.caffe2.TensorProto.DataType.FLOAT)
    def clearDataType: TensorProto = copy(dataType = _root_.scala.None)
    def withDataType(__v: caffe2.caffe2.TensorProto.DataType): TensorProto = copy(dataType = Option(__v))
    def getStorageType: caffe2.caffe2.TensorProto.StorageType = storageType.getOrElse(caffe2.caffe2.TensorProto.StorageType.TYPED)
    def clearStorageType: TensorProto = copy(storageType = _root_.scala.None)
    def withStorageType(__v: caffe2.caffe2.TensorProto.StorageType): TensorProto = copy(storageType = Option(__v))
    def clearFloatData = copy(floatData = _root_.scala.Seq.empty)
    def addFloatData(__vs: _root_.scala.Float*): TensorProto = addAllFloatData(__vs)
    def addAllFloatData(__vs: Iterable[_root_.scala.Float]): TensorProto = copy(floatData = floatData ++ __vs)
    def withFloatData(__v: _root_.scala.Seq[_root_.scala.Float]): TensorProto = copy(floatData = __v)
    def clearInt32Data = copy(int32Data = _root_.scala.Seq.empty)
    def addInt32Data(__vs: _root_.scala.Int*): TensorProto = addAllInt32Data(__vs)
    def addAllInt32Data(__vs: Iterable[_root_.scala.Int]): TensorProto = copy(int32Data = int32Data ++ __vs)
    def withInt32Data(__v: _root_.scala.Seq[_root_.scala.Int]): TensorProto = copy(int32Data = __v)
    def getByteData: _root_.com.google.protobuf.ByteString = byteData.getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
    def clearByteData: TensorProto = copy(byteData = _root_.scala.None)
    def withByteData(__v: _root_.com.google.protobuf.ByteString): TensorProto = copy(byteData = Option(__v))
    def clearStringData = copy(stringData = _root_.scala.Seq.empty)
    def addStringData(__vs: _root_.com.google.protobuf.ByteString*): TensorProto = addAllStringData(__vs)
    def addAllStringData(__vs: Iterable[_root_.com.google.protobuf.ByteString]): TensorProto = copy(stringData = stringData ++ __vs)
    def withStringData(__v: _root_.scala.Seq[_root_.com.google.protobuf.ByteString]): TensorProto = copy(stringData = __v)
    def clearDoubleData = copy(doubleData = _root_.scala.Seq.empty)
    def addDoubleData(__vs: _root_.scala.Double*): TensorProto = addAllDoubleData(__vs)
    def addAllDoubleData(__vs: Iterable[_root_.scala.Double]): TensorProto = copy(doubleData = doubleData ++ __vs)
    def withDoubleData(__v: _root_.scala.Seq[_root_.scala.Double]): TensorProto = copy(doubleData = __v)
    def clearInt64Data = copy(int64Data = _root_.scala.Seq.empty)
    def addInt64Data(__vs: _root_.scala.Long*): TensorProto = addAllInt64Data(__vs)
    def addAllInt64Data(__vs: Iterable[_root_.scala.Long]): TensorProto = copy(int64Data = int64Data ++ __vs)
    def withInt64Data(__v: _root_.scala.Seq[_root_.scala.Long]): TensorProto = copy(int64Data = __v)
    def getRawData: _root_.com.google.protobuf.ByteString = rawData.getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
    def clearRawData: TensorProto = copy(rawData = _root_.scala.None)
    def withRawData(__v: _root_.com.google.protobuf.ByteString): TensorProto = copy(rawData = Option(__v))
    def getExternalData: caffe2.caffe2.ExternalDataProto = externalData.getOrElse(caffe2.caffe2.ExternalDataProto.defaultInstance)
    def clearExternalData: TensorProto = copy(externalData = _root_.scala.None)
    def withExternalData(__v: caffe2.caffe2.ExternalDataProto): TensorProto = copy(externalData = Option(__v))
    def getName: _root_.scala.Predef.String = name.getOrElse("")
    def clearName: TensorProto = copy(name = _root_.scala.None)
    def withName(__v: _root_.scala.Predef.String): TensorProto = copy(name = Option(__v))
    def getDeviceDetail: caffe2.caffe2.DeviceOption = deviceDetail.getOrElse(caffe2.caffe2.DeviceOption.defaultInstance)
    def clearDeviceDetail: TensorProto = copy(deviceDetail = _root_.scala.None)
    def withDeviceDetail(__v: caffe2.caffe2.DeviceOption): TensorProto = copy(deviceDetail = Option(__v))
    def getSegment: caffe2.caffe2.TensorProto.Segment = segment.getOrElse(caffe2.caffe2.TensorProto.Segment.defaultInstance)
    def clearSegment: TensorProto = copy(segment = _root_.scala.None)
    def withSegment(__v: caffe2.caffe2.TensorProto.Segment): TensorProto = copy(segment = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => dims
        case 2 => dataType.map(_.javaValueDescriptor).orNull
        case 12 => storageType.map(_.javaValueDescriptor).orNull
        case 3 => floatData
        case 4 => int32Data
        case 5 => byteData.orNull
        case 6 => stringData
        case 9 => doubleData
        case 10 => int64Data
        case 13 => rawData.orNull
        case 14 => externalData.orNull
        case 7 => name.orNull
        case 8 => deviceDetail.orNull
        case 11 => segment.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PRepeated(dims.iterator.map(_root_.scalapb.descriptors.PLong(_)).toVector)
        case 2 => dataType.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 12 => storageType.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => _root_.scalapb.descriptors.PRepeated(floatData.iterator.map(_root_.scalapb.descriptors.PFloat(_)).toVector)
        case 4 => _root_.scalapb.descriptors.PRepeated(int32Data.iterator.map(_root_.scalapb.descriptors.PInt(_)).toVector)
        case 5 => byteData.map(_root_.scalapb.descriptors.PByteString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => _root_.scalapb.descriptors.PRepeated(stringData.iterator.map(_root_.scalapb.descriptors.PByteString(_)).toVector)
        case 9 => _root_.scalapb.descriptors.PRepeated(doubleData.iterator.map(_root_.scalapb.descriptors.PDouble(_)).toVector)
        case 10 => _root_.scalapb.descriptors.PRepeated(int64Data.iterator.map(_root_.scalapb.descriptors.PLong(_)).toVector)
        case 13 => rawData.map(_root_.scalapb.descriptors.PByteString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 14 => externalData.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => name.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 8 => deviceDetail.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 11 => segment.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = caffe2.caffe2.TensorProto
    // @@protoc_insertion_point(GeneratedMessage[caffe2.TensorProto])
}

object TensorProto extends scalapb.GeneratedMessageCompanion[caffe2.caffe2.TensorProto] with scalapb.HasBuilder[caffe2.caffe2.TensorProto] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[caffe2.caffe2.TensorProto] with scalapb.HasBuilder[caffe2.caffe2.TensorProto] = this
  def merge(`_message__`: caffe2.caffe2.TensorProto, `_input__`: _root_.com.google.protobuf.CodedInputStream): caffe2.caffe2.TensorProto = newBuilder(_message__).merge(_input__).result()
  implicit def messageReads: _root_.scalapb.descriptors.Reads[caffe2.caffe2.TensorProto] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      caffe2.caffe2.TensorProto(
        dims = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Seq[_root_.scala.Long]]).getOrElse(_root_.scala.Seq.empty),
        dataType = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => caffe2.caffe2.TensorProto.DataType.fromValue(__e.number)),
        storageType = __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).flatMap(_.as[_root_.scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => caffe2.caffe2.TensorProto.StorageType.fromValue(__e.number)),
        floatData = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Seq[_root_.scala.Float]]).getOrElse(_root_.scala.Seq.empty),
        int32Data = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Seq[_root_.scala.Int]]).getOrElse(_root_.scala.Seq.empty),
        byteData = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[_root_.com.google.protobuf.ByteString]]),
        stringData = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Seq[_root_.com.google.protobuf.ByteString]]).getOrElse(_root_.scala.Seq.empty),
        doubleData = __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).map(_.as[_root_.scala.Seq[_root_.scala.Double]]).getOrElse(_root_.scala.Seq.empty),
        int64Data = __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).map(_.as[_root_.scala.Seq[_root_.scala.Long]]).getOrElse(_root_.scala.Seq.empty),
        rawData = __fieldsMap.get(scalaDescriptor.findFieldByNumber(13).get).flatMap(_.as[_root_.scala.Option[_root_.com.google.protobuf.ByteString]]),
        externalData = __fieldsMap.get(scalaDescriptor.findFieldByNumber(14).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.ExternalDataProto]]),
        name = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        deviceDetail = __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.DeviceOption]]),
        segment = __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.TensorProto.Segment]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = Caffe2Proto.javaDescriptor.getMessageTypes().get(1)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = Caffe2Proto.scalaDescriptor.messages(1)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 14 => __out = caffe2.caffe2.ExternalDataProto
      case 8 => __out = caffe2.caffe2.DeviceOption
      case 11 => __out = caffe2.caffe2.TensorProto.Segment
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      _root_.caffe2.caffe2.TensorProto.Segment
    )
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 2 => caffe2.caffe2.TensorProto.DataType
      case 12 => caffe2.caffe2.TensorProto.StorageType
    }
  }
  lazy val defaultInstance = caffe2.caffe2.TensorProto(
    dims = _root_.scala.Seq.empty,
    dataType = _root_.scala.None,
    storageType = _root_.scala.None,
    floatData = _root_.scala.Seq.empty,
    int32Data = _root_.scala.Seq.empty,
    byteData = _root_.scala.None,
    stringData = _root_.scala.Seq.empty,
    doubleData = _root_.scala.Seq.empty,
    int64Data = _root_.scala.Seq.empty,
    rawData = _root_.scala.None,
    externalData = _root_.scala.None,
    name = _root_.scala.None,
    deviceDetail = _root_.scala.None,
    segment = _root_.scala.None
  )
  final class Builder private (
    private val __dims: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long],
    private var __dataType: _root_.scala.Option[caffe2.caffe2.TensorProto.DataType],
    private var __storageType: _root_.scala.Option[caffe2.caffe2.TensorProto.StorageType],
    private val __floatData: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Float],
    private val __int32Data: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Int],
    private var __byteData: _root_.scala.Option[_root_.com.google.protobuf.ByteString],
    private val __stringData: _root_.scala.collection.immutable.VectorBuilder[_root_.com.google.protobuf.ByteString],
    private val __doubleData: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Double],
    private val __int64Data: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long],
    private var __rawData: _root_.scala.Option[_root_.com.google.protobuf.ByteString],
    private var __externalData: _root_.scala.Option[caffe2.caffe2.ExternalDataProto],
    private var __name: _root_.scala.Option[_root_.scala.Predef.String],
    private var __deviceDetail: _root_.scala.Option[caffe2.caffe2.DeviceOption],
    private var __segment: _root_.scala.Option[caffe2.caffe2.TensorProto.Segment],
    private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
  ) extends _root_.scalapb.MessageBuilder[caffe2.caffe2.TensorProto] {
    def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __dims += _input__.readInt64()
          case 10 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __dims += _input__.readInt64()
            }
            _input__.popLimit(oldLimit)
          }
          case 16 =>
            __dataType = Option(caffe2.caffe2.TensorProto.DataType.fromValue(_input__.readEnum()))
          case 96 =>
            __storageType = Option(caffe2.caffe2.TensorProto.StorageType.fromValue(_input__.readEnum()))
          case 29 =>
            __floatData += _input__.readFloat()
          case 26 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __floatData += _input__.readFloat()
            }
            _input__.popLimit(oldLimit)
          }
          case 32 =>
            __int32Data += _input__.readInt32()
          case 34 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __int32Data += _input__.readInt32()
            }
            _input__.popLimit(oldLimit)
          }
          case 42 =>
            __byteData = Option(_input__.readBytes())
          case 50 =>
            __stringData += _input__.readBytes()
          case 73 =>
            __doubleData += _input__.readDouble()
          case 74 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __doubleData += _input__.readDouble()
            }
            _input__.popLimit(oldLimit)
          }
          case 80 =>
            __int64Data += _input__.readInt64()
          case 82 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __int64Data += _input__.readInt64()
            }
            _input__.popLimit(oldLimit)
          }
          case 106 =>
            __rawData = Option(_input__.readBytes())
          case 114 =>
            __externalData = Option(__externalData.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.ExternalDataProto](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 58 =>
            __name = Option(_input__.readStringRequireUtf8())
          case 66 =>
            __deviceDetail = Option(__deviceDetail.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.DeviceOption](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 90 =>
            __segment = Option(__segment.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.TensorProto.Segment](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      this
    }
    def result(): caffe2.caffe2.TensorProto = {
      caffe2.caffe2.TensorProto(
        dims = __dims.result(),
        dataType = __dataType,
        storageType = __storageType,
        floatData = __floatData.result(),
        int32Data = __int32Data.result(),
        byteData = __byteData,
        stringData = __stringData.result(),
        doubleData = __doubleData.result(),
        int64Data = __int64Data.result(),
        rawData = __rawData,
        externalData = __externalData,
        name = __name,
        deviceDetail = __deviceDetail,
        segment = __segment,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
  }
  object Builder extends _root_.scalapb.MessageBuilderCompanion[caffe2.caffe2.TensorProto, caffe2.caffe2.TensorProto.Builder] {
    def apply(): Builder = new Builder(
      __dims = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long],
      __dataType = _root_.scala.None,
      __storageType = _root_.scala.None,
      __floatData = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Float],
      __int32Data = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Int],
      __byteData = _root_.scala.None,
      __stringData = new _root_.scala.collection.immutable.VectorBuilder[_root_.com.google.protobuf.ByteString],
      __doubleData = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Double],
      __int64Data = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long],
      __rawData = _root_.scala.None,
      __externalData = _root_.scala.None,
      __name = _root_.scala.None,
      __deviceDetail = _root_.scala.None,
      __segment = _root_.scala.None,
      `_unknownFields__` = null
    )
    def apply(`_message__`: caffe2.caffe2.TensorProto): Builder = new Builder(
        __dims = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long] ++= _message__.dims,
        __dataType = _message__.dataType,
        __storageType = _message__.storageType,
        __floatData = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Float] ++= _message__.floatData,
        __int32Data = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Int] ++= _message__.int32Data,
        __byteData = _message__.byteData,
        __stringData = new _root_.scala.collection.immutable.VectorBuilder[_root_.com.google.protobuf.ByteString] ++= _message__.stringData,
        __doubleData = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Double] ++= _message__.doubleData,
        __int64Data = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long] ++= _message__.int64Data,
        __rawData = _message__.rawData,
        __externalData = _message__.externalData,
        __name = _message__.name,
        __deviceDetail = _message__.deviceDetail,
        __segment = _message__.segment,
        `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
    )
  }
  def newBuilder: Builder = caffe2.caffe2.TensorProto.Builder()
  def newBuilder(`_message__`: caffe2.caffe2.TensorProto): Builder = caffe2.caffe2.TensorProto.Builder(_message__)
  /** Data type
    */
  sealed abstract class DataType(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
    type EnumType = DataType
    def isUndefined: _root_.scala.Boolean = false
    def isFloat: _root_.scala.Boolean = false
    def isInt32: _root_.scala.Boolean = false
    def isByte: _root_.scala.Boolean = false
    def isString: _root_.scala.Boolean = false
    def isBool: _root_.scala.Boolean = false
    def isUint8: _root_.scala.Boolean = false
    def isInt8: _root_.scala.Boolean = false
    def isUint16: _root_.scala.Boolean = false
    def isInt16: _root_.scala.Boolean = false
    def isInt64: _root_.scala.Boolean = false
    def isFloat16: _root_.scala.Boolean = false
    def isDouble: _root_.scala.Boolean = false
    def isZeroCollisionHash: _root_.scala.Boolean = false
    def companion: _root_.scalapb.GeneratedEnumCompanion[DataType] = caffe2.caffe2.TensorProto.DataType
    final def asRecognized: _root_.scala.Option[caffe2.caffe2.TensorProto.DataType.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[caffe2.caffe2.TensorProto.DataType.Recognized])
  }
  
  object DataType extends _root_.scalapb.GeneratedEnumCompanion[DataType] {
    sealed trait Recognized extends DataType
    implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[DataType] = this
    @SerialVersionUID(0L)
    case object UNDEFINED extends DataType(0) with DataType.Recognized {
      val index = 0
      val name = "UNDEFINED"
      override def isUndefined: _root_.scala.Boolean = true
    }
    
    /** Basic types
      * float
      */
    @SerialVersionUID(0L)
    case object FLOAT extends DataType(1) with DataType.Recognized {
      val index = 1
      val name = "FLOAT"
      override def isFloat: _root_.scala.Boolean = true
    }
    
    /** int
      */
    @SerialVersionUID(0L)
    case object INT32 extends DataType(2) with DataType.Recognized {
      val index = 2
      val name = "INT32"
      override def isInt32: _root_.scala.Boolean = true
    }
    
    /** byte, when deserialized, is going to be restored as uint8
      */
    @SerialVersionUID(0L)
    case object BYTE extends DataType(3) with DataType.Recognized {
      val index = 3
      val name = "BYTE"
      override def isByte: _root_.scala.Boolean = true
    }
    
    /** string
      */
    @SerialVersionUID(0L)
    case object STRING extends DataType(4) with DataType.Recognized {
      val index = 4
      val name = "STRING"
      override def isString: _root_.scala.Boolean = true
    }
    
    /** Less-commonly used data types
      * bool
      */
    @SerialVersionUID(0L)
    case object BOOL extends DataType(5) with DataType.Recognized {
      val index = 5
      val name = "BOOL"
      override def isBool: _root_.scala.Boolean = true
    }
    
    /** uint8_t
      */
    @SerialVersionUID(0L)
    case object UINT8 extends DataType(6) with DataType.Recognized {
      val index = 6
      val name = "UINT8"
      override def isUint8: _root_.scala.Boolean = true
    }
    
    /** int8_t
      */
    @SerialVersionUID(0L)
    case object INT8 extends DataType(7) with DataType.Recognized {
      val index = 7
      val name = "INT8"
      override def isInt8: _root_.scala.Boolean = true
    }
    
    /** uint16_t
      */
    @SerialVersionUID(0L)
    case object UINT16 extends DataType(8) with DataType.Recognized {
      val index = 8
      val name = "UINT16"
      override def isUint16: _root_.scala.Boolean = true
    }
    
    /** int16_t
      */
    @SerialVersionUID(0L)
    case object INT16 extends DataType(9) with DataType.Recognized {
      val index = 9
      val name = "INT16"
      override def isInt16: _root_.scala.Boolean = true
    }
    
    /** int64_t
      */
    @SerialVersionUID(0L)
    case object INT64 extends DataType(10) with DataType.Recognized {
      val index = 10
      val name = "INT64"
      override def isInt64: _root_.scala.Boolean = true
    }
    
    /** at::Half
      */
    @SerialVersionUID(0L)
    case object FLOAT16 extends DataType(12) with DataType.Recognized {
      val index = 11
      val name = "FLOAT16"
      override def isFloat16: _root_.scala.Boolean = true
    }
    
    /** double
      */
    @SerialVersionUID(0L)
    case object DOUBLE extends DataType(13) with DataType.Recognized {
      val index = 12
      val name = "DOUBLE"
      override def isDouble: _root_.scala.Boolean = true
    }
    
    /** zero-collision hash state
      */
    @SerialVersionUID(0L)
    case object ZERO_COLLISION_HASH extends DataType(14) with DataType.Recognized {
      val index = 13
      val name = "ZERO_COLLISION_HASH"
      override def isZeroCollisionHash: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends DataType(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.immutable.Seq(UNDEFINED, FLOAT, INT32, BYTE, STRING, BOOL, UINT8, INT8, UINT16, INT16, INT64, FLOAT16, DOUBLE, ZERO_COLLISION_HASH)
    def fromValue(__value: _root_.scala.Int): DataType = __value match {
      case 0 => UNDEFINED
      case 1 => FLOAT
      case 2 => INT32
      case 3 => BYTE
      case 4 => STRING
      case 5 => BOOL
      case 6 => UINT8
      case 7 => INT8
      case 8 => UINT16
      case 9 => INT16
      case 10 => INT64
      case 12 => FLOAT16
      case 13 => DOUBLE
      case 14 => ZERO_COLLISION_HASH
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = caffe2.caffe2.TensorProto.javaDescriptor.getEnumTypes().get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = caffe2.caffe2.TensorProto.scalaDescriptor.enums(0)
  }
  /** data storage
    */
  sealed abstract class StorageType(val value: _root_.scala.Int) extends _root_.scalapb.GeneratedEnum {
    type EnumType = StorageType
    def isTyped: _root_.scala.Boolean = false
    def isRaw: _root_.scala.Boolean = false
    def isExternal: _root_.scala.Boolean = false
    def isNoContent: _root_.scala.Boolean = false
    def companion: _root_.scalapb.GeneratedEnumCompanion[StorageType] = caffe2.caffe2.TensorProto.StorageType
    final def asRecognized: _root_.scala.Option[caffe2.caffe2.TensorProto.StorageType.Recognized] = if (isUnrecognized) _root_.scala.None else _root_.scala.Some(this.asInstanceOf[caffe2.caffe2.TensorProto.StorageType.Recognized])
  }
  
  object StorageType extends _root_.scalapb.GeneratedEnumCompanion[StorageType] {
    sealed trait Recognized extends StorageType
    implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[StorageType] = this
    /** the content is stored in typed field, for example, if the data_type is
      * FLOAT, float_data is used to store the content.
      */
    @SerialVersionUID(0L)
    case object TYPED extends StorageType(1) with StorageType.Recognized {
      val index = 0
      val name = "TYPED"
      override def isTyped: _root_.scala.Boolean = true
    }
    
    /** the content is serialized in field raw_data as little-endian
      */
    @SerialVersionUID(0L)
    case object RAW extends StorageType(2) with StorageType.Recognized {
      val index = 1
      val name = "RAW"
      override def isRaw: _root_.scala.Boolean = true
    }
    
    /** the pointer to the content is stored in field external_data
      * the content is serialized as little-endian
      */
    @SerialVersionUID(0L)
    case object EXTERNAL extends StorageType(3) with StorageType.Recognized {
      val index = 2
      val name = "EXTERNAL"
      override def isExternal: _root_.scala.Boolean = true
    }
    
    /** When StorageType is NO_CONTENT, we use TensorProto to store only type
      * and shape information. Reuse TensorProto to store type and shape
      * because we can just have one proto, not having another ValueInfoProto
      */
    @SerialVersionUID(0L)
    case object NO_CONTENT extends StorageType(4) with StorageType.Recognized {
      val index = 3
      val name = "NO_CONTENT"
      override def isNoContent: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    final case class Unrecognized(unrecognizedValue: _root_.scala.Int) extends StorageType(unrecognizedValue) with _root_.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.immutable.Seq(TYPED, RAW, EXTERNAL, NO_CONTENT)
    def fromValue(__value: _root_.scala.Int): StorageType = __value match {
      case 1 => TYPED
      case 2 => RAW
      case 3 => EXTERNAL
      case 4 => NO_CONTENT
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = caffe2.caffe2.TensorProto.javaDescriptor.getEnumTypes().get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = caffe2.caffe2.TensorProto.scalaDescriptor.enums(1)
  }
  /** When loading from chunks this is going to indicate where to put data in the
    * full array. When not used full data have to be present
    */
  @SerialVersionUID(0L)
  final case class Segment(
      begin: _root_.scala.Long,
      end: _root_.scala.Long,
      unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
      ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[Segment] {
      @transient
      private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
      private[this] def __computeSerializedValue(): _root_.scala.Int = {
        var __size = 0
        
        {
          val __value = begin
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(1, __value)
        };
        
        {
          val __value = end
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(2, __value)
        };
        __size += unknownFields.serializedSize
        __size
      }
      override def serializedSize: _root_.scala.Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        
        {
          val __v = begin
          _output__.writeInt64(1, __v)
        };
        
        {
          val __v = end
          _output__.writeInt64(2, __v)
        };
        unknownFields.writeTo(_output__)
      }
      def withBegin(__v: _root_.scala.Long): Segment = copy(begin = __v)
      def withEnd(__v: _root_.scala.Long): Segment = copy(end = __v)
      def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
      def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => begin
          case 2 => end
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => _root_.scalapb.descriptors.PLong(begin)
          case 2 => _root_.scalapb.descriptors.PLong(end)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion = caffe2.caffe2.TensorProto.Segment
      // @@protoc_insertion_point(GeneratedMessage[caffe2.TensorProto.Segment])
  }
  
  object Segment extends scalapb.GeneratedMessageCompanion[caffe2.caffe2.TensorProto.Segment] with scalapb.HasBuilder[caffe2.caffe2.TensorProto.Segment] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[caffe2.caffe2.TensorProto.Segment] with scalapb.HasBuilder[caffe2.caffe2.TensorProto.Segment] = this
    def merge(`_message__`: caffe2.caffe2.TensorProto.Segment, `_input__`: _root_.com.google.protobuf.CodedInputStream): caffe2.caffe2.TensorProto.Segment = newBuilder(_message__).merge(_input__).result()
    implicit def messageReads: _root_.scalapb.descriptors.Reads[caffe2.caffe2.TensorProto.Segment] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        caffe2.caffe2.TensorProto.Segment(
          begin = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[_root_.scala.Long],
          end = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).get.as[_root_.scala.Long]
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = caffe2.caffe2.TensorProto.javaDescriptor.getNestedTypes().get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = caffe2.caffe2.TensorProto.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = caffe2.caffe2.TensorProto.Segment(
      begin = 0L,
      end = 0L
    )
    final class Builder private (
      private var __begin: _root_.scala.Long,
      private var __end: _root_.scala.Long,
      private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
    ) extends _root_.scalapb.MessageBuilder[caffe2.caffe2.TensorProto.Segment] {
      private var __requiredFields0: _root_.scala.Long = 0x3L
      def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __begin = _input__.readInt64()
              __requiredFields0 &= 0xfffffffffffffffeL
            case 16 =>
              __end = _input__.readInt64()
              __requiredFields0 &= 0xfffffffffffffffdL
            case tag =>
              if (_unknownFields__ == null) {
                _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
              }
              _unknownFields__.parseField(tag, _input__)
          }
        }
        this
      }
      def result(): caffe2.caffe2.TensorProto.Segment = {
        if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
        caffe2.caffe2.TensorProto.Segment(
          begin = __begin,
          end = __end,
          unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
        )
      }
    }
    object Builder extends _root_.scalapb.MessageBuilderCompanion[caffe2.caffe2.TensorProto.Segment, caffe2.caffe2.TensorProto.Segment.Builder] {
      def apply(): Builder = new Builder(
        __begin = 0L,
        __end = 0L,
        `_unknownFields__` = null
      )
      def apply(`_message__`: caffe2.caffe2.TensorProto.Segment): Builder = new Builder(
          __begin = _message__.begin,
          __end = _message__.end,
          `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
      )
    }
    def newBuilder: Builder = caffe2.caffe2.TensorProto.Segment.Builder()
    def newBuilder(`_message__`: caffe2.caffe2.TensorProto.Segment): Builder = caffe2.caffe2.TensorProto.Segment.Builder(_message__)
    implicit class SegmentLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.TensorProto.Segment]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, caffe2.caffe2.TensorProto.Segment](_l) {
      def begin: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.begin)((c_, f_) => c_.copy(begin = f_))
      def end: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.end)((c_, f_) => c_.copy(end = f_))
    }
    final val BEGIN_FIELD_NUMBER = 1
    final val END_FIELD_NUMBER = 2
    def of(
      begin: _root_.scala.Long,
      end: _root_.scala.Long
    ): _root_.caffe2.caffe2.TensorProto.Segment = _root_.caffe2.caffe2.TensorProto.Segment(
      begin,
      end
    )
    // @@protoc_insertion_point(GeneratedMessageCompanion[caffe2.TensorProto.Segment])
  }
  
  implicit class TensorProtoLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.TensorProto]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, caffe2.caffe2.TensorProto](_l) {
    def dims: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Long]] = field(_.dims)((c_, f_) => c_.copy(dims = f_))
    def dataType: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.TensorProto.DataType] = field(_.getDataType)((c_, f_) => c_.copy(dataType = Option(f_)))
    def optionalDataType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.TensorProto.DataType]] = field(_.dataType)((c_, f_) => c_.copy(dataType = f_))
    def storageType: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.TensorProto.StorageType] = field(_.getStorageType)((c_, f_) => c_.copy(storageType = Option(f_)))
    def optionalStorageType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.TensorProto.StorageType]] = field(_.storageType)((c_, f_) => c_.copy(storageType = f_))
    def floatData: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Float]] = field(_.floatData)((c_, f_) => c_.copy(floatData = f_))
    def int32Data: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Int]] = field(_.int32Data)((c_, f_) => c_.copy(int32Data = f_))
    def byteData: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.getByteData)((c_, f_) => c_.copy(byteData = Option(f_)))
    def optionalByteData: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.com.google.protobuf.ByteString]] = field(_.byteData)((c_, f_) => c_.copy(byteData = f_))
    def stringData: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.com.google.protobuf.ByteString]] = field(_.stringData)((c_, f_) => c_.copy(stringData = f_))
    def doubleData: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Double]] = field(_.doubleData)((c_, f_) => c_.copy(doubleData = f_))
    def int64Data: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Long]] = field(_.int64Data)((c_, f_) => c_.copy(int64Data = f_))
    def rawData: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.getRawData)((c_, f_) => c_.copy(rawData = Option(f_)))
    def optionalRawData: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.com.google.protobuf.ByteString]] = field(_.rawData)((c_, f_) => c_.copy(rawData = f_))
    def externalData: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.ExternalDataProto] = field(_.getExternalData)((c_, f_) => c_.copy(externalData = Option(f_)))
    def optionalExternalData: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.ExternalDataProto]] = field(_.externalData)((c_, f_) => c_.copy(externalData = f_))
    def name: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getName)((c_, f_) => c_.copy(name = Option(f_)))
    def optionalName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.name)((c_, f_) => c_.copy(name = f_))
    def deviceDetail: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.DeviceOption] = field(_.getDeviceDetail)((c_, f_) => c_.copy(deviceDetail = Option(f_)))
    def optionalDeviceDetail: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.DeviceOption]] = field(_.deviceDetail)((c_, f_) => c_.copy(deviceDetail = f_))
    def segment: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.TensorProto.Segment] = field(_.getSegment)((c_, f_) => c_.copy(segment = Option(f_)))
    def optionalSegment: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.TensorProto.Segment]] = field(_.segment)((c_, f_) => c_.copy(segment = f_))
  }
  final val DIMS_FIELD_NUMBER = 1
  final val DATA_TYPE_FIELD_NUMBER = 2
  final val STORAGE_TYPE_FIELD_NUMBER = 12
  final val FLOAT_DATA_FIELD_NUMBER = 3
  final val INT32_DATA_FIELD_NUMBER = 4
  final val BYTE_DATA_FIELD_NUMBER = 5
  final val STRING_DATA_FIELD_NUMBER = 6
  final val DOUBLE_DATA_FIELD_NUMBER = 9
  final val INT64_DATA_FIELD_NUMBER = 10
  final val RAW_DATA_FIELD_NUMBER = 13
  final val EXTERNAL_DATA_FIELD_NUMBER = 14
  final val NAME_FIELD_NUMBER = 7
  final val DEVICE_DETAIL_FIELD_NUMBER = 8
  final val SEGMENT_FIELD_NUMBER = 11
  def of(
    dims: _root_.scala.Seq[_root_.scala.Long],
    dataType: _root_.scala.Option[caffe2.caffe2.TensorProto.DataType],
    storageType: _root_.scala.Option[caffe2.caffe2.TensorProto.StorageType],
    floatData: _root_.scala.Seq[_root_.scala.Float],
    int32Data: _root_.scala.Seq[_root_.scala.Int],
    byteData: _root_.scala.Option[_root_.com.google.protobuf.ByteString],
    stringData: _root_.scala.Seq[_root_.com.google.protobuf.ByteString],
    doubleData: _root_.scala.Seq[_root_.scala.Double],
    int64Data: _root_.scala.Seq[_root_.scala.Long],
    rawData: _root_.scala.Option[_root_.com.google.protobuf.ByteString],
    externalData: _root_.scala.Option[caffe2.caffe2.ExternalDataProto],
    name: _root_.scala.Option[_root_.scala.Predef.String],
    deviceDetail: _root_.scala.Option[caffe2.caffe2.DeviceOption],
    segment: _root_.scala.Option[caffe2.caffe2.TensorProto.Segment]
  ): _root_.caffe2.caffe2.TensorProto = _root_.caffe2.caffe2.TensorProto(
    dims,
    dataType,
    storageType,
    floatData,
    int32Data,
    byteData,
    stringData,
    doubleData,
    int64Data,
    rawData,
    externalData,
    name,
    deviceDetail,
    segment
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[caffe2.TensorProto])
}
