// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package caffe2.caffe2

/** Operator Definition.
  *
  * @param input
  *   the name of the input blobs
  * @param output
  *   the name of output top blobs
  * @param name
  *   the operator name. This is optional.
  * @param type
  *   the operator type. This is needed to create the object from the operator
  *   registry.
  * @param arg
  *   arg is for the argument defined in operator schema
  * @param deviceOption
  *   The device option that the operator should run under.
  * @param engine
  *   Optionally, one can specify an engine when there are multiple
  *   implementations available simultaneously for one device type.
  *   If one specifies an engine but that engine does not exist in the compiled
  *   Caffe2 binary, Caffe2 will fall back to the default engine of that device
  *   type.
  * @param controlInput
  *   Additional 'fake' inputs used for expressing control dependencies
  *   in the operator graph. This can be used to ensure that an
  *   operator does not run until another operator is ready, for e.g.
  *   scheduling control. These are not passed as actual inputs to the
  *   Operator implementation, and are only used by the Net class for
  *   scheduling purposes.
  * @param isGradientOp
  *   is_gradient_op argument is only used as a hint in shape inference
  *   and has no runtime significance
  * @param debugInfo
  *   debug information associated with the construction of the operator.
  *   This is an optional string with no assumed characteristics as
  *   operators can be constructed in any language.
  * @param domain
  *   the domain of the operator to help runtime distinguish which operator
  *   library this OperatorDef refers to. For example, both caffe2 and aten
  *   has `Add` operator, with domain, we can easily decide which operator
  *   to execute. to support multiple operator libs, we use domain to
  *   distinguish which operator lib we refer to:
  *     - "caffe2" means this uses Caffe2 operator library
  *     - "aten" means this uses ATen operator library
  *     - "c10" is for the fused library
  *     - if the domain is missing or empty, we use "caffe2", this is for
  *       legacy models, new serializer should always export an OperatorDef
  *       with domain and op_version
  * @param opVersion
  *   each operator is has its own version number.
  *   operator version information
  *   each time, we change the API or semantics of the operator,
  *   we bump the version for the operator.
  *   the runtime system should check the op_version of each OperatorDef
  *   and decide it should reject or accept the model
  */
@SerialVersionUID(0L)
final case class OperatorDef(
    input: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    output: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    name: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    `type`: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    arg: _root_.scala.Seq[caffe2.caffe2.Argument] = _root_.scala.Seq.empty,
    deviceOption: _root_.scala.Option[caffe2.caffe2.DeviceOption] = _root_.scala.None,
    engine: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    controlInput: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    isGradientOp: _root_.scala.Option[_root_.scala.Boolean] = _root_.scala.None,
    debugInfo: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    domain: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    opVersion: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[OperatorDef] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      input.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
      }
      output.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(2, __value)
      }
      if (name.isDefined) {
        val __value = name.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
      };
      if (`type`.isDefined) {
        val __value = `type`.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(4, __value)
      };
      arg.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      if (deviceOption.isDefined) {
        val __value = deviceOption.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (engine.isDefined) {
        val __value = engine.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(7, __value)
      };
      controlInput.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(8, __value)
      }
      if (isGradientOp.isDefined) {
        val __value = isGradientOp.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(9, __value)
      };
      if (debugInfo.isDefined) {
        val __value = debugInfo.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(10, __value)
      };
      if (domain.isDefined) {
        val __value = domain.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(11, __value)
      };
      if (opVersion.isDefined) {
        val __value = opVersion.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(12, __value)
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      input.foreach { __v =>
        val __m = __v
        _output__.writeString(1, __m)
      };
      output.foreach { __v =>
        val __m = __v
        _output__.writeString(2, __m)
      };
      name.foreach { __v =>
        val __m = __v
        _output__.writeString(3, __m)
      };
      `type`.foreach { __v =>
        val __m = __v
        _output__.writeString(4, __m)
      };
      arg.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      deviceOption.foreach { __v =>
        val __m = __v
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      engine.foreach { __v =>
        val __m = __v
        _output__.writeString(7, __m)
      };
      controlInput.foreach { __v =>
        val __m = __v
        _output__.writeString(8, __m)
      };
      isGradientOp.foreach { __v =>
        val __m = __v
        _output__.writeBool(9, __m)
      };
      debugInfo.foreach { __v =>
        val __m = __v
        _output__.writeString(10, __m)
      };
      domain.foreach { __v =>
        val __m = __v
        _output__.writeString(11, __m)
      };
      opVersion.foreach { __v =>
        val __m = __v
        _output__.writeInt64(12, __m)
      };
      unknownFields.writeTo(_output__)
    }
    def clearInput = copy(input = _root_.scala.Seq.empty)
    def addInput(__vs: _root_.scala.Predef.String*): OperatorDef = addAllInput(__vs)
    def addAllInput(__vs: Iterable[_root_.scala.Predef.String]): OperatorDef = copy(input = input ++ __vs)
    def withInput(__v: _root_.scala.Seq[_root_.scala.Predef.String]): OperatorDef = copy(input = __v)
    def clearOutput = copy(output = _root_.scala.Seq.empty)
    def addOutput(__vs: _root_.scala.Predef.String*): OperatorDef = addAllOutput(__vs)
    def addAllOutput(__vs: Iterable[_root_.scala.Predef.String]): OperatorDef = copy(output = output ++ __vs)
    def withOutput(__v: _root_.scala.Seq[_root_.scala.Predef.String]): OperatorDef = copy(output = __v)
    def getName: _root_.scala.Predef.String = name.getOrElse("")
    def clearName: OperatorDef = copy(name = _root_.scala.None)
    def withName(__v: _root_.scala.Predef.String): OperatorDef = copy(name = Option(__v))
    def getType: _root_.scala.Predef.String = `type`.getOrElse("")
    def clearType: OperatorDef = copy(`type` = _root_.scala.None)
    def withType(__v: _root_.scala.Predef.String): OperatorDef = copy(`type` = Option(__v))
    def clearArg = copy(arg = _root_.scala.Seq.empty)
    def addArg(__vs: caffe2.caffe2.Argument*): OperatorDef = addAllArg(__vs)
    def addAllArg(__vs: Iterable[caffe2.caffe2.Argument]): OperatorDef = copy(arg = arg ++ __vs)
    def withArg(__v: _root_.scala.Seq[caffe2.caffe2.Argument]): OperatorDef = copy(arg = __v)
    def getDeviceOption: caffe2.caffe2.DeviceOption = deviceOption.getOrElse(caffe2.caffe2.DeviceOption.defaultInstance)
    def clearDeviceOption: OperatorDef = copy(deviceOption = _root_.scala.None)
    def withDeviceOption(__v: caffe2.caffe2.DeviceOption): OperatorDef = copy(deviceOption = Option(__v))
    def getEngine: _root_.scala.Predef.String = engine.getOrElse("")
    def clearEngine: OperatorDef = copy(engine = _root_.scala.None)
    def withEngine(__v: _root_.scala.Predef.String): OperatorDef = copy(engine = Option(__v))
    def clearControlInput = copy(controlInput = _root_.scala.Seq.empty)
    def addControlInput(__vs: _root_.scala.Predef.String*): OperatorDef = addAllControlInput(__vs)
    def addAllControlInput(__vs: Iterable[_root_.scala.Predef.String]): OperatorDef = copy(controlInput = controlInput ++ __vs)
    def withControlInput(__v: _root_.scala.Seq[_root_.scala.Predef.String]): OperatorDef = copy(controlInput = __v)
    def getIsGradientOp: _root_.scala.Boolean = isGradientOp.getOrElse(false)
    def clearIsGradientOp: OperatorDef = copy(isGradientOp = _root_.scala.None)
    def withIsGradientOp(__v: _root_.scala.Boolean): OperatorDef = copy(isGradientOp = Option(__v))
    def getDebugInfo: _root_.scala.Predef.String = debugInfo.getOrElse("")
    def clearDebugInfo: OperatorDef = copy(debugInfo = _root_.scala.None)
    def withDebugInfo(__v: _root_.scala.Predef.String): OperatorDef = copy(debugInfo = Option(__v))
    def getDomain: _root_.scala.Predef.String = domain.getOrElse("")
    def clearDomain: OperatorDef = copy(domain = _root_.scala.None)
    def withDomain(__v: _root_.scala.Predef.String): OperatorDef = copy(domain = Option(__v))
    def getOpVersion: _root_.scala.Long = opVersion.getOrElse(0L)
    def clearOpVersion: OperatorDef = copy(opVersion = _root_.scala.None)
    def withOpVersion(__v: _root_.scala.Long): OperatorDef = copy(opVersion = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => input
        case 2 => output
        case 3 => name.orNull
        case 4 => `type`.orNull
        case 5 => arg
        case 6 => deviceOption.orNull
        case 7 => engine.orNull
        case 8 => controlInput
        case 9 => isGradientOp.orNull
        case 10 => debugInfo.orNull
        case 11 => domain.orNull
        case 12 => opVersion.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => _root_.scalapb.descriptors.PRepeated(input.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 2 => _root_.scalapb.descriptors.PRepeated(output.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 3 => name.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => `type`.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => _root_.scalapb.descriptors.PRepeated(arg.iterator.map(_.toPMessage).toVector)
        case 6 => deviceOption.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => engine.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 8 => _root_.scalapb.descriptors.PRepeated(controlInput.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 9 => isGradientOp.map(_root_.scalapb.descriptors.PBoolean(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 10 => debugInfo.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 11 => domain.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 12 => opVersion.map(_root_.scalapb.descriptors.PLong(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = caffe2.caffe2.OperatorDef
    // @@protoc_insertion_point(GeneratedMessage[caffe2.OperatorDef])
}

object OperatorDef extends scalapb.GeneratedMessageCompanion[caffe2.caffe2.OperatorDef] with scalapb.HasBuilder[caffe2.caffe2.OperatorDef] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[caffe2.caffe2.OperatorDef] with scalapb.HasBuilder[caffe2.caffe2.OperatorDef] = this
  def merge(`_message__`: caffe2.caffe2.OperatorDef, `_input__`: _root_.com.google.protobuf.CodedInputStream): caffe2.caffe2.OperatorDef = newBuilder(_message__).merge(_input__).result()
  implicit def messageReads: _root_.scalapb.descriptors.Reads[caffe2.caffe2.OperatorDef] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      caffe2.caffe2.OperatorDef(
        input = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        output = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        name = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        `type` = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        arg = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.Argument]]).getOrElse(_root_.scala.Seq.empty),
        deviceOption = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.DeviceOption]]),
        engine = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        controlInput = __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        isGradientOp = __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Boolean]]),
        debugInfo = __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        domain = __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        opVersion = __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = Caffe2Proto.javaDescriptor.getMessageTypes().get(11)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = Caffe2Proto.scalaDescriptor.messages(11)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 5 => __out = caffe2.caffe2.Argument
      case 6 => __out = caffe2.caffe2.DeviceOption
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = caffe2.caffe2.OperatorDef(
    input = _root_.scala.Seq.empty,
    output = _root_.scala.Seq.empty,
    name = _root_.scala.None,
    `type` = _root_.scala.None,
    arg = _root_.scala.Seq.empty,
    deviceOption = _root_.scala.None,
    engine = _root_.scala.None,
    controlInput = _root_.scala.Seq.empty,
    isGradientOp = _root_.scala.None,
    debugInfo = _root_.scala.None,
    domain = _root_.scala.None,
    opVersion = _root_.scala.None
  )
  final class Builder private (
    private val __input: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
    private val __output: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
    private var __name: _root_.scala.Option[_root_.scala.Predef.String],
    private var __type: _root_.scala.Option[_root_.scala.Predef.String],
    private val __arg: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.Argument],
    private var __deviceOption: _root_.scala.Option[caffe2.caffe2.DeviceOption],
    private var __engine: _root_.scala.Option[_root_.scala.Predef.String],
    private val __controlInput: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
    private var __isGradientOp: _root_.scala.Option[_root_.scala.Boolean],
    private var __debugInfo: _root_.scala.Option[_root_.scala.Predef.String],
    private var __domain: _root_.scala.Option[_root_.scala.Predef.String],
    private var __opVersion: _root_.scala.Option[_root_.scala.Long],
    private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
  ) extends _root_.scalapb.MessageBuilder[caffe2.caffe2.OperatorDef] {
    def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __input += _input__.readStringRequireUtf8()
          case 18 =>
            __output += _input__.readStringRequireUtf8()
          case 26 =>
            __name = Option(_input__.readStringRequireUtf8())
          case 34 =>
            __type = Option(_input__.readStringRequireUtf8())
          case 42 =>
            __arg += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.Argument](_input__)
          case 50 =>
            __deviceOption = Option(__deviceOption.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.DeviceOption](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 58 =>
            __engine = Option(_input__.readStringRequireUtf8())
          case 66 =>
            __controlInput += _input__.readStringRequireUtf8()
          case 72 =>
            __isGradientOp = Option(_input__.readBool())
          case 82 =>
            __debugInfo = Option(_input__.readStringRequireUtf8())
          case 90 =>
            __domain = Option(_input__.readStringRequireUtf8())
          case 96 =>
            __opVersion = Option(_input__.readInt64())
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      this
    }
    def result(): caffe2.caffe2.OperatorDef = {
      caffe2.caffe2.OperatorDef(
        input = __input.result(),
        output = __output.result(),
        name = __name,
        `type` = __type,
        arg = __arg.result(),
        deviceOption = __deviceOption,
        engine = __engine,
        controlInput = __controlInput.result(),
        isGradientOp = __isGradientOp,
        debugInfo = __debugInfo,
        domain = __domain,
        opVersion = __opVersion,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
  }
  object Builder extends _root_.scalapb.MessageBuilderCompanion[caffe2.caffe2.OperatorDef, caffe2.caffe2.OperatorDef.Builder] {
    def apply(): Builder = new Builder(
      __input = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
      __output = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
      __name = _root_.scala.None,
      __type = _root_.scala.None,
      __arg = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.Argument],
      __deviceOption = _root_.scala.None,
      __engine = _root_.scala.None,
      __controlInput = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
      __isGradientOp = _root_.scala.None,
      __debugInfo = _root_.scala.None,
      __domain = _root_.scala.None,
      __opVersion = _root_.scala.None,
      `_unknownFields__` = null
    )
    def apply(`_message__`: caffe2.caffe2.OperatorDef): Builder = new Builder(
        __input = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] ++= _message__.input,
        __output = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] ++= _message__.output,
        __name = _message__.name,
        __type = _message__.`type`,
        __arg = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.Argument] ++= _message__.arg,
        __deviceOption = _message__.deviceOption,
        __engine = _message__.engine,
        __controlInput = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] ++= _message__.controlInput,
        __isGradientOp = _message__.isGradientOp,
        __debugInfo = _message__.debugInfo,
        __domain = _message__.domain,
        __opVersion = _message__.opVersion,
        `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
    )
  }
  def newBuilder: Builder = caffe2.caffe2.OperatorDef.Builder()
  def newBuilder(`_message__`: caffe2.caffe2.OperatorDef): Builder = caffe2.caffe2.OperatorDef.Builder(_message__)
  implicit class OperatorDefLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.OperatorDef]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, caffe2.caffe2.OperatorDef](_l) {
    def input: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.input)((c_, f_) => c_.copy(input = f_))
    def output: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.output)((c_, f_) => c_.copy(output = f_))
    def name: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getName)((c_, f_) => c_.copy(name = Option(f_)))
    def optionalName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.name)((c_, f_) => c_.copy(name = f_))
    def `type`: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getType)((c_, f_) => c_.copy(`type` = Option(f_)))
    def optionalType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def arg: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.Argument]] = field(_.arg)((c_, f_) => c_.copy(arg = f_))
    def deviceOption: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.DeviceOption] = field(_.getDeviceOption)((c_, f_) => c_.copy(deviceOption = Option(f_)))
    def optionalDeviceOption: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.DeviceOption]] = field(_.deviceOption)((c_, f_) => c_.copy(deviceOption = f_))
    def engine: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getEngine)((c_, f_) => c_.copy(engine = Option(f_)))
    def optionalEngine: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.engine)((c_, f_) => c_.copy(engine = f_))
    def controlInput: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.controlInput)((c_, f_) => c_.copy(controlInput = f_))
    def isGradientOp: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.getIsGradientOp)((c_, f_) => c_.copy(isGradientOp = Option(f_)))
    def optionalIsGradientOp: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Boolean]] = field(_.isGradientOp)((c_, f_) => c_.copy(isGradientOp = f_))
    def debugInfo: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getDebugInfo)((c_, f_) => c_.copy(debugInfo = Option(f_)))
    def optionalDebugInfo: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.debugInfo)((c_, f_) => c_.copy(debugInfo = f_))
    def domain: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getDomain)((c_, f_) => c_.copy(domain = Option(f_)))
    def optionalDomain: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.domain)((c_, f_) => c_.copy(domain = f_))
    def opVersion: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getOpVersion)((c_, f_) => c_.copy(opVersion = Option(f_)))
    def optionalOpVersion: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.opVersion)((c_, f_) => c_.copy(opVersion = f_))
  }
  final val INPUT_FIELD_NUMBER = 1
  final val OUTPUT_FIELD_NUMBER = 2
  final val NAME_FIELD_NUMBER = 3
  final val TYPE_FIELD_NUMBER = 4
  final val ARG_FIELD_NUMBER = 5
  final val DEVICE_OPTION_FIELD_NUMBER = 6
  final val ENGINE_FIELD_NUMBER = 7
  final val CONTROL_INPUT_FIELD_NUMBER = 8
  final val IS_GRADIENT_OP_FIELD_NUMBER = 9
  final val DEBUG_INFO_FIELD_NUMBER = 10
  final val DOMAIN_FIELD_NUMBER = 11
  final val OP_VERSION_FIELD_NUMBER = 12
  def of(
    input: _root_.scala.Seq[_root_.scala.Predef.String],
    output: _root_.scala.Seq[_root_.scala.Predef.String],
    name: _root_.scala.Option[_root_.scala.Predef.String],
    `type`: _root_.scala.Option[_root_.scala.Predef.String],
    arg: _root_.scala.Seq[caffe2.caffe2.Argument],
    deviceOption: _root_.scala.Option[caffe2.caffe2.DeviceOption],
    engine: _root_.scala.Option[_root_.scala.Predef.String],
    controlInput: _root_.scala.Seq[_root_.scala.Predef.String],
    isGradientOp: _root_.scala.Option[_root_.scala.Boolean],
    debugInfo: _root_.scala.Option[_root_.scala.Predef.String],
    domain: _root_.scala.Option[_root_.scala.Predef.String],
    opVersion: _root_.scala.Option[_root_.scala.Long]
  ): _root_.caffe2.caffe2.OperatorDef = _root_.caffe2.caffe2.OperatorDef(
    input,
    output,
    name,
    `type`,
    arg,
    deviceOption,
    engine,
    controlInput,
    isGradientOp,
    debugInfo,
    domain,
    opVersion
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[caffe2.OperatorDef])
}
