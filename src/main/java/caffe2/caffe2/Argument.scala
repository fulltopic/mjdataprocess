// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package caffe2.caffe2

/** A named argument containing either singular float, integer and string
  * values, or repeated float, int and string arrays.
  */
@SerialVersionUID(0L)
final case class Argument(
    name: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    f: _root_.scala.Option[_root_.scala.Float] = _root_.scala.None,
    i: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
    s: _root_.scala.Option[_root_.com.google.protobuf.ByteString] = _root_.scala.None,
    t: _root_.scala.Option[caffe2.caffe2.TensorProto] = _root_.scala.None,
    n: _root_.scala.Option[caffe2.caffe2.NetDef] = _root_.scala.None,
    floats: _root_.scala.Seq[_root_.scala.Float] = _root_.scala.Seq.empty,
    ints: _root_.scala.Seq[_root_.scala.Long] = _root_.scala.Seq.empty,
    strings: _root_.scala.Seq[_root_.com.google.protobuf.ByteString] = _root_.scala.Seq.empty,
    tensors: _root_.scala.Seq[caffe2.caffe2.TensorProto] = _root_.scala.Seq.empty,
    nets: _root_.scala.Seq[caffe2.caffe2.NetDef] = _root_.scala.Seq.empty,
    qtensors: _root_.scala.Seq[caffe2.caffe2.QTensorProto] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[Argument] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (name.isDefined) {
        val __value = name.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
      };
      if (f.isDefined) {
        val __value = f.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeFloatSize(2, __value)
      };
      if (i.isDefined) {
        val __value = i.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(3, __value)
      };
      if (s.isDefined) {
        val __value = s.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(4, __value)
      };
      if (t.isDefined) {
        val __value = t.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (n.isDefined) {
        val __value = n.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      __size += 5 * floats.size
      ints.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(6, __value)
      }
      strings.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBytesSize(7, __value)
      }
      tensors.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      nets.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      qtensors.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      name.foreach { __v =>
        val __m = __v
        _output__.writeString(1, __m)
      };
      f.foreach { __v =>
        val __m = __v
        _output__.writeFloat(2, __m)
      };
      i.foreach { __v =>
        val __m = __v
        _output__.writeInt64(3, __m)
      };
      s.foreach { __v =>
        val __m = __v
        _output__.writeBytes(4, __m)
      };
      floats.foreach { __v =>
        val __m = __v
        _output__.writeFloat(5, __m)
      };
      ints.foreach { __v =>
        val __m = __v
        _output__.writeInt64(6, __m)
      };
      strings.foreach { __v =>
        val __m = __v
        _output__.writeBytes(7, __m)
      };
      n.foreach { __v =>
        val __m = __v
        _output__.writeTag(8, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      nets.foreach { __v =>
        val __m = __v
        _output__.writeTag(9, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      t.foreach { __v =>
        val __m = __v
        _output__.writeTag(10, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      tensors.foreach { __v =>
        val __m = __v
        _output__.writeTag(11, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      qtensors.foreach { __v =>
        val __m = __v
        _output__.writeTag(12, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getName: _root_.scala.Predef.String = name.getOrElse("")
    def clearName: Argument = copy(name = _root_.scala.None)
    def withName(__v: _root_.scala.Predef.String): Argument = copy(name = Option(__v))
    def getF: _root_.scala.Float = f.getOrElse(0.0f)
    def clearF: Argument = copy(f = _root_.scala.None)
    def withF(__v: _root_.scala.Float): Argument = copy(f = Option(__v))
    def getI: _root_.scala.Long = i.getOrElse(0L)
    def clearI: Argument = copy(i = _root_.scala.None)
    def withI(__v: _root_.scala.Long): Argument = copy(i = Option(__v))
    def getS: _root_.com.google.protobuf.ByteString = s.getOrElse(_root_.com.google.protobuf.ByteString.EMPTY)
    def clearS: Argument = copy(s = _root_.scala.None)
    def withS(__v: _root_.com.google.protobuf.ByteString): Argument = copy(s = Option(__v))
    def getT: caffe2.caffe2.TensorProto = t.getOrElse(caffe2.caffe2.TensorProto.defaultInstance)
    def clearT: Argument = copy(t = _root_.scala.None)
    def withT(__v: caffe2.caffe2.TensorProto): Argument = copy(t = Option(__v))
    def getN: caffe2.caffe2.NetDef = n.getOrElse(caffe2.caffe2.NetDef.defaultInstance)
    def clearN: Argument = copy(n = _root_.scala.None)
    def withN(__v: caffe2.caffe2.NetDef): Argument = copy(n = Option(__v))
    def clearFloats = copy(floats = _root_.scala.Seq.empty)
    def addFloats(__vs: _root_.scala.Float*): Argument = addAllFloats(__vs)
    def addAllFloats(__vs: Iterable[_root_.scala.Float]): Argument = copy(floats = floats ++ __vs)
    def withFloats(__v: _root_.scala.Seq[_root_.scala.Float]): Argument = copy(floats = __v)
    def clearInts = copy(ints = _root_.scala.Seq.empty)
    def addInts(__vs: _root_.scala.Long*): Argument = addAllInts(__vs)
    def addAllInts(__vs: Iterable[_root_.scala.Long]): Argument = copy(ints = ints ++ __vs)
    def withInts(__v: _root_.scala.Seq[_root_.scala.Long]): Argument = copy(ints = __v)
    def clearStrings = copy(strings = _root_.scala.Seq.empty)
    def addStrings(__vs: _root_.com.google.protobuf.ByteString*): Argument = addAllStrings(__vs)
    def addAllStrings(__vs: Iterable[_root_.com.google.protobuf.ByteString]): Argument = copy(strings = strings ++ __vs)
    def withStrings(__v: _root_.scala.Seq[_root_.com.google.protobuf.ByteString]): Argument = copy(strings = __v)
    def clearTensors = copy(tensors = _root_.scala.Seq.empty)
    def addTensors(__vs: caffe2.caffe2.TensorProto*): Argument = addAllTensors(__vs)
    def addAllTensors(__vs: Iterable[caffe2.caffe2.TensorProto]): Argument = copy(tensors = tensors ++ __vs)
    def withTensors(__v: _root_.scala.Seq[caffe2.caffe2.TensorProto]): Argument = copy(tensors = __v)
    def clearNets = copy(nets = _root_.scala.Seq.empty)
    def addNets(__vs: caffe2.caffe2.NetDef*): Argument = addAllNets(__vs)
    def addAllNets(__vs: Iterable[caffe2.caffe2.NetDef]): Argument = copy(nets = nets ++ __vs)
    def withNets(__v: _root_.scala.Seq[caffe2.caffe2.NetDef]): Argument = copy(nets = __v)
    def clearQtensors = copy(qtensors = _root_.scala.Seq.empty)
    def addQtensors(__vs: caffe2.caffe2.QTensorProto*): Argument = addAllQtensors(__vs)
    def addAllQtensors(__vs: Iterable[caffe2.caffe2.QTensorProto]): Argument = copy(qtensors = qtensors ++ __vs)
    def withQtensors(__v: _root_.scala.Seq[caffe2.caffe2.QTensorProto]): Argument = copy(qtensors = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => name.orNull
        case 2 => f.orNull
        case 3 => i.orNull
        case 4 => s.orNull
        case 10 => t.orNull
        case 8 => n.orNull
        case 5 => floats
        case 6 => ints
        case 7 => strings
        case 11 => tensors
        case 9 => nets
        case 12 => qtensors
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => name.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => f.map(_root_.scalapb.descriptors.PFloat(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => i.map(_root_.scalapb.descriptors.PLong(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => s.map(_root_.scalapb.descriptors.PByteString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 10 => t.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 8 => n.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => _root_.scalapb.descriptors.PRepeated(floats.iterator.map(_root_.scalapb.descriptors.PFloat(_)).toVector)
        case 6 => _root_.scalapb.descriptors.PRepeated(ints.iterator.map(_root_.scalapb.descriptors.PLong(_)).toVector)
        case 7 => _root_.scalapb.descriptors.PRepeated(strings.iterator.map(_root_.scalapb.descriptors.PByteString(_)).toVector)
        case 11 => _root_.scalapb.descriptors.PRepeated(tensors.iterator.map(_.toPMessage).toVector)
        case 9 => _root_.scalapb.descriptors.PRepeated(nets.iterator.map(_.toPMessage).toVector)
        case 12 => _root_.scalapb.descriptors.PRepeated(qtensors.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = caffe2.caffe2.Argument
    // @@protoc_insertion_point(GeneratedMessage[caffe2.Argument])
}

object Argument extends scalapb.GeneratedMessageCompanion[caffe2.caffe2.Argument] with scalapb.HasBuilder[caffe2.caffe2.Argument] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[caffe2.caffe2.Argument] with scalapb.HasBuilder[caffe2.caffe2.Argument] = this
  def merge(`_message__`: caffe2.caffe2.Argument, `_input__`: _root_.com.google.protobuf.CodedInputStream): caffe2.caffe2.Argument = newBuilder(_message__).merge(_input__).result()
  implicit def messageReads: _root_.scalapb.descriptors.Reads[caffe2.caffe2.Argument] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      caffe2.caffe2.Argument(
        name = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        f = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Float]]),
        i = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]]),
        s = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.com.google.protobuf.ByteString]]),
        t = __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.TensorProto]]),
        n = __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.NetDef]]),
        floats = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Seq[_root_.scala.Float]]).getOrElse(_root_.scala.Seq.empty),
        ints = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Seq[_root_.scala.Long]]).getOrElse(_root_.scala.Seq.empty),
        strings = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).map(_.as[_root_.scala.Seq[_root_.com.google.protobuf.ByteString]]).getOrElse(_root_.scala.Seq.empty),
        tensors = __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.TensorProto]]).getOrElse(_root_.scala.Seq.empty),
        nets = __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.NetDef]]).getOrElse(_root_.scala.Seq.empty),
        qtensors = __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.QTensorProto]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = Caffe2Proto.javaDescriptor.getMessageTypes().get(9)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = Caffe2Proto.scalaDescriptor.messages(9)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 10 => __out = caffe2.caffe2.TensorProto
      case 8 => __out = caffe2.caffe2.NetDef
      case 11 => __out = caffe2.caffe2.TensorProto
      case 9 => __out = caffe2.caffe2.NetDef
      case 12 => __out = caffe2.caffe2.QTensorProto
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = caffe2.caffe2.Argument(
    name = _root_.scala.None,
    f = _root_.scala.None,
    i = _root_.scala.None,
    s = _root_.scala.None,
    t = _root_.scala.None,
    n = _root_.scala.None,
    floats = _root_.scala.Seq.empty,
    ints = _root_.scala.Seq.empty,
    strings = _root_.scala.Seq.empty,
    tensors = _root_.scala.Seq.empty,
    nets = _root_.scala.Seq.empty,
    qtensors = _root_.scala.Seq.empty
  )
  final class Builder private (
    private var __name: _root_.scala.Option[_root_.scala.Predef.String],
    private var __f: _root_.scala.Option[_root_.scala.Float],
    private var __i: _root_.scala.Option[_root_.scala.Long],
    private var __s: _root_.scala.Option[_root_.com.google.protobuf.ByteString],
    private var __t: _root_.scala.Option[caffe2.caffe2.TensorProto],
    private var __n: _root_.scala.Option[caffe2.caffe2.NetDef],
    private val __floats: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Float],
    private val __ints: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long],
    private val __strings: _root_.scala.collection.immutable.VectorBuilder[_root_.com.google.protobuf.ByteString],
    private val __tensors: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.TensorProto],
    private val __nets: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.NetDef],
    private val __qtensors: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.QTensorProto],
    private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
  ) extends _root_.scalapb.MessageBuilder[caffe2.caffe2.Argument] {
    def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __name = Option(_input__.readStringRequireUtf8())
          case 21 =>
            __f = Option(_input__.readFloat())
          case 24 =>
            __i = Option(_input__.readInt64())
          case 34 =>
            __s = Option(_input__.readBytes())
          case 82 =>
            __t = Option(__t.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.TensorProto](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 66 =>
            __n = Option(__n.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.NetDef](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 45 =>
            __floats += _input__.readFloat()
          case 42 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __floats += _input__.readFloat()
            }
            _input__.popLimit(oldLimit)
          }
          case 48 =>
            __ints += _input__.readInt64()
          case 50 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __ints += _input__.readInt64()
            }
            _input__.popLimit(oldLimit)
          }
          case 58 =>
            __strings += _input__.readBytes()
          case 90 =>
            __tensors += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.TensorProto](_input__)
          case 74 =>
            __nets += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.NetDef](_input__)
          case 98 =>
            __qtensors += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.QTensorProto](_input__)
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      this
    }
    def result(): caffe2.caffe2.Argument = {
      caffe2.caffe2.Argument(
        name = __name,
        f = __f,
        i = __i,
        s = __s,
        t = __t,
        n = __n,
        floats = __floats.result(),
        ints = __ints.result(),
        strings = __strings.result(),
        tensors = __tensors.result(),
        nets = __nets.result(),
        qtensors = __qtensors.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
  }
  object Builder extends _root_.scalapb.MessageBuilderCompanion[caffe2.caffe2.Argument, caffe2.caffe2.Argument.Builder] {
    def apply(): Builder = new Builder(
      __name = _root_.scala.None,
      __f = _root_.scala.None,
      __i = _root_.scala.None,
      __s = _root_.scala.None,
      __t = _root_.scala.None,
      __n = _root_.scala.None,
      __floats = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Float],
      __ints = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long],
      __strings = new _root_.scala.collection.immutable.VectorBuilder[_root_.com.google.protobuf.ByteString],
      __tensors = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.TensorProto],
      __nets = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.NetDef],
      __qtensors = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.QTensorProto],
      `_unknownFields__` = null
    )
    def apply(`_message__`: caffe2.caffe2.Argument): Builder = new Builder(
        __name = _message__.name,
        __f = _message__.f,
        __i = _message__.i,
        __s = _message__.s,
        __t = _message__.t,
        __n = _message__.n,
        __floats = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Float] ++= _message__.floats,
        __ints = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Long] ++= _message__.ints,
        __strings = new _root_.scala.collection.immutable.VectorBuilder[_root_.com.google.protobuf.ByteString] ++= _message__.strings,
        __tensors = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.TensorProto] ++= _message__.tensors,
        __nets = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.NetDef] ++= _message__.nets,
        __qtensors = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.QTensorProto] ++= _message__.qtensors,
        `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
    )
  }
  def newBuilder: Builder = caffe2.caffe2.Argument.Builder()
  def newBuilder(`_message__`: caffe2.caffe2.Argument): Builder = caffe2.caffe2.Argument.Builder(_message__)
  implicit class ArgumentLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.Argument]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, caffe2.caffe2.Argument](_l) {
    def name: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getName)((c_, f_) => c_.copy(name = Option(f_)))
    def optionalName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.name)((c_, f_) => c_.copy(name = f_))
    def f: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Float] = field(_.getF)((c_, f_) => c_.copy(f = Option(f_)))
    def optionalF: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Float]] = field(_.f)((c_, f_) => c_.copy(f = f_))
    def i: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getI)((c_, f_) => c_.copy(i = Option(f_)))
    def optionalI: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.i)((c_, f_) => c_.copy(i = f_))
    def s: _root_.scalapb.lenses.Lens[UpperPB, _root_.com.google.protobuf.ByteString] = field(_.getS)((c_, f_) => c_.copy(s = Option(f_)))
    def optionalS: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.com.google.protobuf.ByteString]] = field(_.s)((c_, f_) => c_.copy(s = f_))
    def t: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.TensorProto] = field(_.getT)((c_, f_) => c_.copy(t = Option(f_)))
    def optionalT: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.TensorProto]] = field(_.t)((c_, f_) => c_.copy(t = f_))
    def n: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.NetDef] = field(_.getN)((c_, f_) => c_.copy(n = Option(f_)))
    def optionalN: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.NetDef]] = field(_.n)((c_, f_) => c_.copy(n = f_))
    def floats: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Float]] = field(_.floats)((c_, f_) => c_.copy(floats = f_))
    def ints: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Long]] = field(_.ints)((c_, f_) => c_.copy(ints = f_))
    def strings: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.com.google.protobuf.ByteString]] = field(_.strings)((c_, f_) => c_.copy(strings = f_))
    def tensors: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.TensorProto]] = field(_.tensors)((c_, f_) => c_.copy(tensors = f_))
    def nets: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.NetDef]] = field(_.nets)((c_, f_) => c_.copy(nets = f_))
    def qtensors: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.QTensorProto]] = field(_.qtensors)((c_, f_) => c_.copy(qtensors = f_))
  }
  final val NAME_FIELD_NUMBER = 1
  final val F_FIELD_NUMBER = 2
  final val I_FIELD_NUMBER = 3
  final val S_FIELD_NUMBER = 4
  final val T_FIELD_NUMBER = 10
  final val N_FIELD_NUMBER = 8
  final val FLOATS_FIELD_NUMBER = 5
  final val INTS_FIELD_NUMBER = 6
  final val STRINGS_FIELD_NUMBER = 7
  final val TENSORS_FIELD_NUMBER = 11
  final val NETS_FIELD_NUMBER = 9
  final val QTENSORS_FIELD_NUMBER = 12
  def of(
    name: _root_.scala.Option[_root_.scala.Predef.String],
    f: _root_.scala.Option[_root_.scala.Float],
    i: _root_.scala.Option[_root_.scala.Long],
    s: _root_.scala.Option[_root_.com.google.protobuf.ByteString],
    t: _root_.scala.Option[caffe2.caffe2.TensorProto],
    n: _root_.scala.Option[caffe2.caffe2.NetDef],
    floats: _root_.scala.Seq[_root_.scala.Float],
    ints: _root_.scala.Seq[_root_.scala.Long],
    strings: _root_.scala.Seq[_root_.com.google.protobuf.ByteString],
    tensors: _root_.scala.Seq[caffe2.caffe2.TensorProto],
    nets: _root_.scala.Seq[caffe2.caffe2.NetDef],
    qtensors: _root_.scala.Seq[caffe2.caffe2.QTensorProto]
  ): _root_.caffe2.caffe2.Argument = _root_.caffe2.caffe2.Argument(
    name,
    f,
    i,
    s,
    t,
    n,
    floats,
    ints,
    strings,
    tensors,
    nets,
    qtensors
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[caffe2.Argument])
}
