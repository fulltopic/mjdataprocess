// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package caffe2.caffe2

/** Network definition.
  *
  * @param name
  *   the network's name
  * @param op
  *   Operators that the network contains.
  *   Note: this is not named "operator" because that is a reserved word in C++.
  * @param type
  *   The type of network that the net should be run with. This routes the
  *   network instantiation to different execution modes. The default mode,
  *   "simple", runs the operators in a sequential way as the original Caffe
  *   implementation does.
  * @param numWorkers
  *   the number of workers, if the operators in the network is to be carried out
  *   in parallel.
  *   Note: This is to be deprecated. Using the arg field with "num_workers" as
  *   key.
  *   Note 2: The old uses of this were never actually cleaned up
  * @param deviceOption
  *   The device option for the network. If a network has a specific device
  *   option and one of its operators does not have it set, we will copy over the
  *   device option to the operator. This allows us to basically avoid putting
  *   device options at every operator.
  * @param externalInput
  *   Two optional fields to declare external input and output of a net.
  *   If these two are set, when a net is created, we will sanity check for
  *   every op whether its input is declared (either as an external input,
  *   or as an intermediate blob created by one of the ops), and sanity check
  *   if all blobs in external_output are produced.
  *  
  *   In cases of memory optimization, declaring external_input and
  *   external_output also ensures that storage of these blobs are persistent:
  *   for any blob in external_input and external_output, after a network run
  *   finishes, their content are actually the right content. Any intermediate
  *   blobs' contents may be overwritten.
  * @param partitionInfo
  *   Partitioning info, indexed by partition names.
  */
@SerialVersionUID(0L)
final case class NetDef(
    name: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    op: _root_.scala.Seq[caffe2.caffe2.OperatorDef] = _root_.scala.Seq.empty,
    `type`: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    numWorkers: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
    deviceOption: _root_.scala.Option[caffe2.caffe2.DeviceOption] = _root_.scala.None,
    arg: _root_.scala.Seq[caffe2.caffe2.Argument] = _root_.scala.Seq.empty,
    externalInput: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    externalOutput: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    partitionInfo: _root_.scala.Seq[caffe2.caffe2.PartitionInfo] = _root_.scala.Seq.empty,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[NetDef] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (name.isDefined) {
        val __value = name.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
      };
      op.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      if (`type`.isDefined) {
        val __value = `type`.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
      };
      if (numWorkers.isDefined) {
        val __value = numWorkers.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(4, __value)
      };
      if (deviceOption.isDefined) {
        val __value = deviceOption.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      arg.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      externalInput.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(7, __value)
      }
      externalOutput.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(8, __value)
      }
      partitionInfo.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      name.foreach { __v =>
        val __m = __v
        _output__.writeString(1, __m)
      };
      op.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      `type`.foreach { __v =>
        val __m = __v
        _output__.writeString(3, __m)
      };
      numWorkers.foreach { __v =>
        val __m = __v
        _output__.writeInt32(4, __m)
      };
      deviceOption.foreach { __v =>
        val __m = __v
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      arg.foreach { __v =>
        val __m = __v
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      externalInput.foreach { __v =>
        val __m = __v
        _output__.writeString(7, __m)
      };
      externalOutput.foreach { __v =>
        val __m = __v
        _output__.writeString(8, __m)
      };
      partitionInfo.foreach { __v =>
        val __m = __v
        _output__.writeTag(9, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      unknownFields.writeTo(_output__)
    }
    def getName: _root_.scala.Predef.String = name.getOrElse("")
    def clearName: NetDef = copy(name = _root_.scala.None)
    def withName(__v: _root_.scala.Predef.String): NetDef = copy(name = Option(__v))
    def clearOp = copy(op = _root_.scala.Seq.empty)
    def addOp(__vs: caffe2.caffe2.OperatorDef*): NetDef = addAllOp(__vs)
    def addAllOp(__vs: Iterable[caffe2.caffe2.OperatorDef]): NetDef = copy(op = op ++ __vs)
    def withOp(__v: _root_.scala.Seq[caffe2.caffe2.OperatorDef]): NetDef = copy(op = __v)
    def getType: _root_.scala.Predef.String = `type`.getOrElse("")
    def clearType: NetDef = copy(`type` = _root_.scala.None)
    def withType(__v: _root_.scala.Predef.String): NetDef = copy(`type` = Option(__v))
    def getNumWorkers: _root_.scala.Int = numWorkers.getOrElse(0)
    def clearNumWorkers: NetDef = copy(numWorkers = _root_.scala.None)
    def withNumWorkers(__v: _root_.scala.Int): NetDef = copy(numWorkers = Option(__v))
    def getDeviceOption: caffe2.caffe2.DeviceOption = deviceOption.getOrElse(caffe2.caffe2.DeviceOption.defaultInstance)
    def clearDeviceOption: NetDef = copy(deviceOption = _root_.scala.None)
    def withDeviceOption(__v: caffe2.caffe2.DeviceOption): NetDef = copy(deviceOption = Option(__v))
    def clearArg = copy(arg = _root_.scala.Seq.empty)
    def addArg(__vs: caffe2.caffe2.Argument*): NetDef = addAllArg(__vs)
    def addAllArg(__vs: Iterable[caffe2.caffe2.Argument]): NetDef = copy(arg = arg ++ __vs)
    def withArg(__v: _root_.scala.Seq[caffe2.caffe2.Argument]): NetDef = copy(arg = __v)
    def clearExternalInput = copy(externalInput = _root_.scala.Seq.empty)
    def addExternalInput(__vs: _root_.scala.Predef.String*): NetDef = addAllExternalInput(__vs)
    def addAllExternalInput(__vs: Iterable[_root_.scala.Predef.String]): NetDef = copy(externalInput = externalInput ++ __vs)
    def withExternalInput(__v: _root_.scala.Seq[_root_.scala.Predef.String]): NetDef = copy(externalInput = __v)
    def clearExternalOutput = copy(externalOutput = _root_.scala.Seq.empty)
    def addExternalOutput(__vs: _root_.scala.Predef.String*): NetDef = addAllExternalOutput(__vs)
    def addAllExternalOutput(__vs: Iterable[_root_.scala.Predef.String]): NetDef = copy(externalOutput = externalOutput ++ __vs)
    def withExternalOutput(__v: _root_.scala.Seq[_root_.scala.Predef.String]): NetDef = copy(externalOutput = __v)
    def clearPartitionInfo = copy(partitionInfo = _root_.scala.Seq.empty)
    def addPartitionInfo(__vs: caffe2.caffe2.PartitionInfo*): NetDef = addAllPartitionInfo(__vs)
    def addAllPartitionInfo(__vs: Iterable[caffe2.caffe2.PartitionInfo]): NetDef = copy(partitionInfo = partitionInfo ++ __vs)
    def withPartitionInfo(__v: _root_.scala.Seq[caffe2.caffe2.PartitionInfo]): NetDef = copy(partitionInfo = __v)
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => name.orNull
        case 2 => op
        case 3 => `type`.orNull
        case 4 => numWorkers.orNull
        case 5 => deviceOption.orNull
        case 6 => arg
        case 7 => externalInput
        case 8 => externalOutput
        case 9 => partitionInfo
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => name.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => _root_.scalapb.descriptors.PRepeated(op.iterator.map(_.toPMessage).toVector)
        case 3 => `type`.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 4 => numWorkers.map(_root_.scalapb.descriptors.PInt(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => deviceOption.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => _root_.scalapb.descriptors.PRepeated(arg.iterator.map(_.toPMessage).toVector)
        case 7 => _root_.scalapb.descriptors.PRepeated(externalInput.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 8 => _root_.scalapb.descriptors.PRepeated(externalOutput.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 9 => _root_.scalapb.descriptors.PRepeated(partitionInfo.iterator.map(_.toPMessage).toVector)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = caffe2.caffe2.NetDef
    // @@protoc_insertion_point(GeneratedMessage[caffe2.NetDef])
}

object NetDef extends scalapb.GeneratedMessageCompanion[caffe2.caffe2.NetDef] with scalapb.HasBuilder[caffe2.caffe2.NetDef] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[caffe2.caffe2.NetDef] with scalapb.HasBuilder[caffe2.caffe2.NetDef] = this
  def merge(`_message__`: caffe2.caffe2.NetDef, `_input__`: _root_.com.google.protobuf.CodedInputStream): caffe2.caffe2.NetDef = newBuilder(_message__).merge(_input__).result()
  implicit def messageReads: _root_.scalapb.descriptors.Reads[caffe2.caffe2.NetDef] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      caffe2.caffe2.NetDef(
        name = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        op = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.OperatorDef]]).getOrElse(_root_.scala.Seq.empty),
        `type` = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        numWorkers = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]]),
        deviceOption = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[caffe2.caffe2.DeviceOption]]),
        arg = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.Argument]]).getOrElse(_root_.scala.Seq.empty),
        externalInput = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        externalOutput = __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        partitionInfo = __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.PartitionInfo]]).getOrElse(_root_.scala.Seq.empty)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = Caffe2Proto.javaDescriptor.getMessageTypes().get(15)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = Caffe2Proto.scalaDescriptor.messages(15)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = caffe2.caffe2.OperatorDef
      case 5 => __out = caffe2.caffe2.DeviceOption
      case 6 => __out = caffe2.caffe2.Argument
      case 9 => __out = caffe2.caffe2.PartitionInfo
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = caffe2.caffe2.NetDef(
    name = _root_.scala.None,
    op = _root_.scala.Seq.empty,
    `type` = _root_.scala.None,
    numWorkers = _root_.scala.None,
    deviceOption = _root_.scala.None,
    arg = _root_.scala.Seq.empty,
    externalInput = _root_.scala.Seq.empty,
    externalOutput = _root_.scala.Seq.empty,
    partitionInfo = _root_.scala.Seq.empty
  )
  final class Builder private (
    private var __name: _root_.scala.Option[_root_.scala.Predef.String],
    private val __op: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.OperatorDef],
    private var __type: _root_.scala.Option[_root_.scala.Predef.String],
    private var __numWorkers: _root_.scala.Option[_root_.scala.Int],
    private var __deviceOption: _root_.scala.Option[caffe2.caffe2.DeviceOption],
    private val __arg: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.Argument],
    private val __externalInput: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
    private val __externalOutput: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
    private val __partitionInfo: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.PartitionInfo],
    private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
  ) extends _root_.scalapb.MessageBuilder[caffe2.caffe2.NetDef] {
    def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __name = Option(_input__.readStringRequireUtf8())
          case 18 =>
            __op += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.OperatorDef](_input__)
          case 26 =>
            __type = Option(_input__.readStringRequireUtf8())
          case 32 =>
            __numWorkers = Option(_input__.readInt32())
          case 42 =>
            __deviceOption = Option(__deviceOption.fold(_root_.scalapb.LiteParser.readMessage[caffe2.caffe2.DeviceOption](_input__))(_root_.scalapb.LiteParser.readMessage(_input__, _)))
          case 50 =>
            __arg += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.Argument](_input__)
          case 58 =>
            __externalInput += _input__.readStringRequireUtf8()
          case 66 =>
            __externalOutput += _input__.readStringRequireUtf8()
          case 74 =>
            __partitionInfo += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.PartitionInfo](_input__)
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      this
    }
    def result(): caffe2.caffe2.NetDef = {
      caffe2.caffe2.NetDef(
        name = __name,
        op = __op.result(),
        `type` = __type,
        numWorkers = __numWorkers,
        deviceOption = __deviceOption,
        arg = __arg.result(),
        externalInput = __externalInput.result(),
        externalOutput = __externalOutput.result(),
        partitionInfo = __partitionInfo.result(),
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
  }
  object Builder extends _root_.scalapb.MessageBuilderCompanion[caffe2.caffe2.NetDef, caffe2.caffe2.NetDef.Builder] {
    def apply(): Builder = new Builder(
      __name = _root_.scala.None,
      __op = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.OperatorDef],
      __type = _root_.scala.None,
      __numWorkers = _root_.scala.None,
      __deviceOption = _root_.scala.None,
      __arg = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.Argument],
      __externalInput = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
      __externalOutput = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
      __partitionInfo = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.PartitionInfo],
      `_unknownFields__` = null
    )
    def apply(`_message__`: caffe2.caffe2.NetDef): Builder = new Builder(
        __name = _message__.name,
        __op = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.OperatorDef] ++= _message__.op,
        __type = _message__.`type`,
        __numWorkers = _message__.numWorkers,
        __deviceOption = _message__.deviceOption,
        __arg = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.Argument] ++= _message__.arg,
        __externalInput = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] ++= _message__.externalInput,
        __externalOutput = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] ++= _message__.externalOutput,
        __partitionInfo = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.PartitionInfo] ++= _message__.partitionInfo,
        `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
    )
  }
  def newBuilder: Builder = caffe2.caffe2.NetDef.Builder()
  def newBuilder(`_message__`: caffe2.caffe2.NetDef): Builder = caffe2.caffe2.NetDef.Builder(_message__)
  implicit class NetDefLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.NetDef]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, caffe2.caffe2.NetDef](_l) {
    def name: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getName)((c_, f_) => c_.copy(name = Option(f_)))
    def optionalName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.name)((c_, f_) => c_.copy(name = f_))
    def op: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.OperatorDef]] = field(_.op)((c_, f_) => c_.copy(op = f_))
    def `type`: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getType)((c_, f_) => c_.copy(`type` = Option(f_)))
    def optionalType: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.`type`)((c_, f_) => c_.copy(`type` = f_))
    def numWorkers: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getNumWorkers)((c_, f_) => c_.copy(numWorkers = Option(f_)))
    def optionalNumWorkers: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.numWorkers)((c_, f_) => c_.copy(numWorkers = f_))
    def deviceOption: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.DeviceOption] = field(_.getDeviceOption)((c_, f_) => c_.copy(deviceOption = Option(f_)))
    def optionalDeviceOption: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[caffe2.caffe2.DeviceOption]] = field(_.deviceOption)((c_, f_) => c_.copy(deviceOption = f_))
    def arg: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.Argument]] = field(_.arg)((c_, f_) => c_.copy(arg = f_))
    def externalInput: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.externalInput)((c_, f_) => c_.copy(externalInput = f_))
    def externalOutput: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.externalOutput)((c_, f_) => c_.copy(externalOutput = f_))
    def partitionInfo: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.PartitionInfo]] = field(_.partitionInfo)((c_, f_) => c_.copy(partitionInfo = f_))
  }
  final val NAME_FIELD_NUMBER = 1
  final val OP_FIELD_NUMBER = 2
  final val TYPE_FIELD_NUMBER = 3
  final val NUM_WORKERS_FIELD_NUMBER = 4
  final val DEVICE_OPTION_FIELD_NUMBER = 5
  final val ARG_FIELD_NUMBER = 6
  final val EXTERNAL_INPUT_FIELD_NUMBER = 7
  final val EXTERNAL_OUTPUT_FIELD_NUMBER = 8
  final val PARTITION_INFO_FIELD_NUMBER = 9
  def of(
    name: _root_.scala.Option[_root_.scala.Predef.String],
    op: _root_.scala.Seq[caffe2.caffe2.OperatorDef],
    `type`: _root_.scala.Option[_root_.scala.Predef.String],
    numWorkers: _root_.scala.Option[_root_.scala.Int],
    deviceOption: _root_.scala.Option[caffe2.caffe2.DeviceOption],
    arg: _root_.scala.Seq[caffe2.caffe2.Argument],
    externalInput: _root_.scala.Seq[_root_.scala.Predef.String],
    externalOutput: _root_.scala.Seq[_root_.scala.Predef.String],
    partitionInfo: _root_.scala.Seq[caffe2.caffe2.PartitionInfo]
  ): _root_.caffe2.caffe2.NetDef = _root_.caffe2.caffe2.NetDef(
    name,
    op,
    `type`,
    numWorkers,
    deviceOption,
    arg,
    externalInput,
    externalOutput,
    partitionInfo
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[caffe2.NetDef])
}
