// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package caffe2.caffe2

/** ExecutionStep is actually a sort-of-hacky way we simulate iteration right
  * now.
  *
  * @param name
  *   ExecutionStep should either contain a set of substeps, or a set of
  *   network names to run in this execution step. They should NOT both be set
  *   at the same time.
  * @param substep
  *   An execution step could be recursive, in which it involves a set of
  *   substeps.
  * @param network
  *   Alternatively, an execution step could involve one or more networks.
  *   Note that you cannot have both substeps and networks. Choose one.
  *   Note that an execution step refers networks by their name. The actual
  *   network definition of the same name should be included in the network field
  *   of the plan. The reason is that a network object might hold internal states
  *   (think of a data layer), so we want to have the same network object that
  *   multiple steps could ask to run.
  * @param numIter
  *   Number of iterations to run this step. The substeps or the networks
  *   specified will be run sequentially, and one sequential run is considered
  *   one iteration. If this is not set, the number of iterations is assumed to
  *   be 1.
  * @param criteriaNetwork
  *   Criteria network specifies a single output (TensorCPU&lt;bool&gt;) of
  *   size (1), is run on every iteration by the executor, and
  *   execution terminates when the output[0] is `false`.
  * @param reportNet
  *   DEPRECATED. Use `run_every_ms`.
  * @param runEveryMs
  *   If provided, execute this step at every time interval (in millisecs)
  *   while its sibiling execution steps execute in parallel. This step is
  *   guaranteed to run at least once after all non-interval siblings finished.
  * @param concurrentSubsteps
  *   If false or not set, execute sub-steps serially.
  *   If true, execute all substeps concurrently, each one in a separate thread.
  * @param shouldStopBlob
  *   Name of a scalar boolean tensor.
  *   ES checks this blob AFTER every substeps/subnets.
  *   If specified, and the value is true, then ES will skip the rest and return
  *   immediately.
  *   This means that the report_net and the first step will always be called.
  *   Use cases:
  *   1) the first substep stops the rest if data condition not met
  *   2) the first substep decide which of the rest of the steps should be run.
  *   3) external control
  *  
  *   ** It is the user's responsibility to not to put this blob in race conditions.
  *   ** For example when setting this blob in concurrent substeps
  * @param onlyOnce
  *   if only_once is true, this step will only be executed once. this ONLY takes
  *   effect when using should_stop_blob
  * @param createWorkspace
  *   Whether to create a child workspace for this step.
  *   If yes, the workflow and nets are re-created every time this step is run.
  * @param numConcurrentInstances
  *   How many copies of the children execution steps to run concurrently.
  */
@SerialVersionUID(0L)
final case class ExecutionStep(
    name: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    substep: _root_.scala.Seq[caffe2.caffe2.ExecutionStep] = _root_.scala.Seq.empty,
    network: _root_.scala.Seq[_root_.scala.Predef.String] = _root_.scala.Seq.empty,
    numIter: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
    @scala.deprecated(message="Marked as deprecated in proto file", "") criteriaNetwork: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    reportNet: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    reportInterval: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
    runEveryMs: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
    concurrentSubsteps: _root_.scala.Option[_root_.scala.Boolean] = _root_.scala.None,
    shouldStopBlob: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    onlyOnce: _root_.scala.Option[_root_.scala.Boolean] = _root_.scala.None,
    createWorkspace: _root_.scala.Option[_root_.scala.Boolean] = _root_.scala.None,
    numConcurrentInstances: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet.empty
    ) extends scalapb.GeneratedMessage with scalapb.lenses.Updatable[ExecutionStep] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (name.isDefined) {
        val __value = name.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
      };
      substep.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      network.foreach { __item =>
        val __value = __item
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(3, __value)
      }
      if (numIter.isDefined) {
        val __value = numIter.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(4, __value)
      };
      if (criteriaNetwork.isDefined) {
        val __value = criteriaNetwork.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(5, __value)
      };
      if (reportNet.isDefined) {
        val __value = reportNet.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(7, __value)
      };
      if (reportInterval.isDefined) {
        val __value = reportInterval.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(8, __value)
      };
      if (runEveryMs.isDefined) {
        val __value = runEveryMs.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(11, __value)
      };
      if (concurrentSubsteps.isDefined) {
        val __value = concurrentSubsteps.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(6, __value)
      };
      if (shouldStopBlob.isDefined) {
        val __value = shouldStopBlob.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(9, __value)
      };
      if (onlyOnce.isDefined) {
        val __value = onlyOnce.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(10, __value)
      };
      if (createWorkspace.isDefined) {
        val __value = createWorkspace.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(12, __value)
      };
      if (numConcurrentInstances.isDefined) {
        val __value = numConcurrentInstances.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(13, __value)
      };
      __size += unknownFields.serializedSize
      __size
    }
    override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      name.foreach { __v =>
        val __m = __v
        _output__.writeString(1, __m)
      };
      substep.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      network.foreach { __v =>
        val __m = __v
        _output__.writeString(3, __m)
      };
      numIter.foreach { __v =>
        val __m = __v
        _output__.writeInt64(4, __m)
      };
      criteriaNetwork.foreach { __v =>
        val __m = __v
        _output__.writeString(5, __m)
      };
      concurrentSubsteps.foreach { __v =>
        val __m = __v
        _output__.writeBool(6, __m)
      };
      reportNet.foreach { __v =>
        val __m = __v
        _output__.writeString(7, __m)
      };
      reportInterval.foreach { __v =>
        val __m = __v
        _output__.writeInt32(8, __m)
      };
      shouldStopBlob.foreach { __v =>
        val __m = __v
        _output__.writeString(9, __m)
      };
      onlyOnce.foreach { __v =>
        val __m = __v
        _output__.writeBool(10, __m)
      };
      runEveryMs.foreach { __v =>
        val __m = __v
        _output__.writeInt64(11, __m)
      };
      createWorkspace.foreach { __v =>
        val __m = __v
        _output__.writeBool(12, __m)
      };
      numConcurrentInstances.foreach { __v =>
        val __m = __v
        _output__.writeInt32(13, __m)
      };
      unknownFields.writeTo(_output__)
    }
    def getName: _root_.scala.Predef.String = name.getOrElse("")
    def clearName: ExecutionStep = copy(name = _root_.scala.None)
    def withName(__v: _root_.scala.Predef.String): ExecutionStep = copy(name = Option(__v))
    def clearSubstep = copy(substep = _root_.scala.Seq.empty)
    def addSubstep(__vs: caffe2.caffe2.ExecutionStep*): ExecutionStep = addAllSubstep(__vs)
    def addAllSubstep(__vs: Iterable[caffe2.caffe2.ExecutionStep]): ExecutionStep = copy(substep = substep ++ __vs)
    def withSubstep(__v: _root_.scala.Seq[caffe2.caffe2.ExecutionStep]): ExecutionStep = copy(substep = __v)
    def clearNetwork = copy(network = _root_.scala.Seq.empty)
    def addNetwork(__vs: _root_.scala.Predef.String*): ExecutionStep = addAllNetwork(__vs)
    def addAllNetwork(__vs: Iterable[_root_.scala.Predef.String]): ExecutionStep = copy(network = network ++ __vs)
    def withNetwork(__v: _root_.scala.Seq[_root_.scala.Predef.String]): ExecutionStep = copy(network = __v)
    def getNumIter: _root_.scala.Long = numIter.getOrElse(0L)
    def clearNumIter: ExecutionStep = copy(numIter = _root_.scala.None)
    def withNumIter(__v: _root_.scala.Long): ExecutionStep = copy(numIter = Option(__v))
    def getCriteriaNetwork: _root_.scala.Predef.String = criteriaNetwork.getOrElse("")
    def clearCriteriaNetwork: ExecutionStep = copy(criteriaNetwork = _root_.scala.None)
    def withCriteriaNetwork(__v: _root_.scala.Predef.String): ExecutionStep = copy(criteriaNetwork = Option(__v))
    def getReportNet: _root_.scala.Predef.String = reportNet.getOrElse("")
    def clearReportNet: ExecutionStep = copy(reportNet = _root_.scala.None)
    def withReportNet(__v: _root_.scala.Predef.String): ExecutionStep = copy(reportNet = Option(__v))
    def getReportInterval: _root_.scala.Int = reportInterval.getOrElse(0)
    def clearReportInterval: ExecutionStep = copy(reportInterval = _root_.scala.None)
    def withReportInterval(__v: _root_.scala.Int): ExecutionStep = copy(reportInterval = Option(__v))
    def getRunEveryMs: _root_.scala.Long = runEveryMs.getOrElse(0L)
    def clearRunEveryMs: ExecutionStep = copy(runEveryMs = _root_.scala.None)
    def withRunEveryMs(__v: _root_.scala.Long): ExecutionStep = copy(runEveryMs = Option(__v))
    def getConcurrentSubsteps: _root_.scala.Boolean = concurrentSubsteps.getOrElse(false)
    def clearConcurrentSubsteps: ExecutionStep = copy(concurrentSubsteps = _root_.scala.None)
    def withConcurrentSubsteps(__v: _root_.scala.Boolean): ExecutionStep = copy(concurrentSubsteps = Option(__v))
    def getShouldStopBlob: _root_.scala.Predef.String = shouldStopBlob.getOrElse("")
    def clearShouldStopBlob: ExecutionStep = copy(shouldStopBlob = _root_.scala.None)
    def withShouldStopBlob(__v: _root_.scala.Predef.String): ExecutionStep = copy(shouldStopBlob = Option(__v))
    def getOnlyOnce: _root_.scala.Boolean = onlyOnce.getOrElse(false)
    def clearOnlyOnce: ExecutionStep = copy(onlyOnce = _root_.scala.None)
    def withOnlyOnce(__v: _root_.scala.Boolean): ExecutionStep = copy(onlyOnce = Option(__v))
    def getCreateWorkspace: _root_.scala.Boolean = createWorkspace.getOrElse(false)
    def clearCreateWorkspace: ExecutionStep = copy(createWorkspace = _root_.scala.None)
    def withCreateWorkspace(__v: _root_.scala.Boolean): ExecutionStep = copy(createWorkspace = Option(__v))
    def getNumConcurrentInstances: _root_.scala.Int = numConcurrentInstances.getOrElse(0)
    def clearNumConcurrentInstances: ExecutionStep = copy(numConcurrentInstances = _root_.scala.None)
    def withNumConcurrentInstances(__v: _root_.scala.Int): ExecutionStep = copy(numConcurrentInstances = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => name.orNull
        case 2 => substep
        case 3 => network
        case 4 => numIter.orNull
        case 5 => criteriaNetwork.orNull
        case 7 => reportNet.orNull
        case 8 => reportInterval.orNull
        case 11 => runEveryMs.orNull
        case 6 => concurrentSubsteps.orNull
        case 9 => shouldStopBlob.orNull
        case 10 => onlyOnce.orNull
        case 12 => createWorkspace.orNull
        case 13 => numConcurrentInstances.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => name.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => _root_.scalapb.descriptors.PRepeated(substep.iterator.map(_.toPMessage).toVector)
        case 3 => _root_.scalapb.descriptors.PRepeated(network.iterator.map(_root_.scalapb.descriptors.PString(_)).toVector)
        case 4 => numIter.map(_root_.scalapb.descriptors.PLong(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => criteriaNetwork.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 7 => reportNet.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 8 => reportInterval.map(_root_.scalapb.descriptors.PInt(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 11 => runEveryMs.map(_root_.scalapb.descriptors.PLong(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 6 => concurrentSubsteps.map(_root_.scalapb.descriptors.PBoolean(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 9 => shouldStopBlob.map(_root_.scalapb.descriptors.PString(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 10 => onlyOnce.map(_root_.scalapb.descriptors.PBoolean(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 12 => createWorkspace.map(_root_.scalapb.descriptors.PBoolean(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 13 => numConcurrentInstances.map(_root_.scalapb.descriptors.PInt(_)).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = caffe2.caffe2.ExecutionStep
    // @@protoc_insertion_point(GeneratedMessage[caffe2.ExecutionStep])
}

object ExecutionStep extends scalapb.GeneratedMessageCompanion[caffe2.caffe2.ExecutionStep] with scalapb.HasBuilder[caffe2.caffe2.ExecutionStep] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[caffe2.caffe2.ExecutionStep] with scalapb.HasBuilder[caffe2.caffe2.ExecutionStep] = this
  def merge(`_message__`: caffe2.caffe2.ExecutionStep, `_input__`: _root_.com.google.protobuf.CodedInputStream): caffe2.caffe2.ExecutionStep = newBuilder(_message__).merge(_input__).result()
  implicit def messageReads: _root_.scalapb.descriptors.Reads[caffe2.caffe2.ExecutionStep] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      caffe2.caffe2.ExecutionStep(
        name = __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        substep = __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[caffe2.caffe2.ExecutionStep]]).getOrElse(_root_.scala.Seq.empty),
        network = __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Seq[_root_.scala.Predef.String]]).getOrElse(_root_.scala.Seq.empty),
        numIter = __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]]),
        criteriaNetwork = __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        reportNet = __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        reportInterval = __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]]),
        runEveryMs = __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]]),
        concurrentSubsteps = __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Boolean]]),
        shouldStopBlob = __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        onlyOnce = __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Boolean]]),
        createWorkspace = __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Boolean]]),
        numConcurrentInstances = __fieldsMap.get(scalaDescriptor.findFieldByNumber(13).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = Caffe2Proto.javaDescriptor.getMessageTypes().get(16)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = Caffe2Proto.scalaDescriptor.messages(16)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 2 => __out = caffe2.caffe2.ExecutionStep
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = caffe2.caffe2.ExecutionStep(
    name = _root_.scala.None,
    substep = _root_.scala.Seq.empty,
    network = _root_.scala.Seq.empty,
    numIter = _root_.scala.None,
    criteriaNetwork = _root_.scala.None,
    reportNet = _root_.scala.None,
    reportInterval = _root_.scala.None,
    runEveryMs = _root_.scala.None,
    concurrentSubsteps = _root_.scala.None,
    shouldStopBlob = _root_.scala.None,
    onlyOnce = _root_.scala.None,
    createWorkspace = _root_.scala.None,
    numConcurrentInstances = _root_.scala.None
  )
  final class Builder private (
    private var __name: _root_.scala.Option[_root_.scala.Predef.String],
    private val __substep: _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.ExecutionStep],
    private val __network: _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
    private var __numIter: _root_.scala.Option[_root_.scala.Long],
    private var __criteriaNetwork: _root_.scala.Option[_root_.scala.Predef.String],
    private var __reportNet: _root_.scala.Option[_root_.scala.Predef.String],
    private var __reportInterval: _root_.scala.Option[_root_.scala.Int],
    private var __runEveryMs: _root_.scala.Option[_root_.scala.Long],
    private var __concurrentSubsteps: _root_.scala.Option[_root_.scala.Boolean],
    private var __shouldStopBlob: _root_.scala.Option[_root_.scala.Predef.String],
    private var __onlyOnce: _root_.scala.Option[_root_.scala.Boolean],
    private var __createWorkspace: _root_.scala.Option[_root_.scala.Boolean],
    private var __numConcurrentInstances: _root_.scala.Option[_root_.scala.Int],
    private var `_unknownFields__`: _root_.scalapb.UnknownFieldSet.Builder
  ) extends _root_.scalapb.MessageBuilder[caffe2.caffe2.ExecutionStep] {
    def merge(`_input__`: _root_.com.google.protobuf.CodedInputStream): this.type = {
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __name = Option(_input__.readStringRequireUtf8())
          case 18 =>
            __substep += _root_.scalapb.LiteParser.readMessage[caffe2.caffe2.ExecutionStep](_input__)
          case 26 =>
            __network += _input__.readStringRequireUtf8()
          case 32 =>
            __numIter = Option(_input__.readInt64())
          case 42 =>
            __criteriaNetwork = Option(_input__.readStringRequireUtf8())
          case 58 =>
            __reportNet = Option(_input__.readStringRequireUtf8())
          case 64 =>
            __reportInterval = Option(_input__.readInt32())
          case 88 =>
            __runEveryMs = Option(_input__.readInt64())
          case 48 =>
            __concurrentSubsteps = Option(_input__.readBool())
          case 74 =>
            __shouldStopBlob = Option(_input__.readStringRequireUtf8())
          case 80 =>
            __onlyOnce = Option(_input__.readBool())
          case 96 =>
            __createWorkspace = Option(_input__.readBool())
          case 104 =>
            __numConcurrentInstances = Option(_input__.readInt32())
          case tag =>
            if (_unknownFields__ == null) {
              _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder()
            }
            _unknownFields__.parseField(tag, _input__)
        }
      }
      this
    }
    def result(): caffe2.caffe2.ExecutionStep = {
      caffe2.caffe2.ExecutionStep(
        name = __name,
        substep = __substep.result(),
        network = __network.result(),
        numIter = __numIter,
        criteriaNetwork = __criteriaNetwork,
        reportNet = __reportNet,
        reportInterval = __reportInterval,
        runEveryMs = __runEveryMs,
        concurrentSubsteps = __concurrentSubsteps,
        shouldStopBlob = __shouldStopBlob,
        onlyOnce = __onlyOnce,
        createWorkspace = __createWorkspace,
        numConcurrentInstances = __numConcurrentInstances,
        unknownFields = if (_unknownFields__ == null) _root_.scalapb.UnknownFieldSet.empty else _unknownFields__.result()
      )
    }
  }
  object Builder extends _root_.scalapb.MessageBuilderCompanion[caffe2.caffe2.ExecutionStep, caffe2.caffe2.ExecutionStep.Builder] {
    def apply(): Builder = new Builder(
      __name = _root_.scala.None,
      __substep = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.ExecutionStep],
      __network = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String],
      __numIter = _root_.scala.None,
      __criteriaNetwork = _root_.scala.None,
      __reportNet = _root_.scala.None,
      __reportInterval = _root_.scala.None,
      __runEveryMs = _root_.scala.None,
      __concurrentSubsteps = _root_.scala.None,
      __shouldStopBlob = _root_.scala.None,
      __onlyOnce = _root_.scala.None,
      __createWorkspace = _root_.scala.None,
      __numConcurrentInstances = _root_.scala.None,
      `_unknownFields__` = null
    )
    def apply(`_message__`: caffe2.caffe2.ExecutionStep): Builder = new Builder(
        __name = _message__.name,
        __substep = new _root_.scala.collection.immutable.VectorBuilder[caffe2.caffe2.ExecutionStep] ++= _message__.substep,
        __network = new _root_.scala.collection.immutable.VectorBuilder[_root_.scala.Predef.String] ++= _message__.network,
        __numIter = _message__.numIter,
        __criteriaNetwork = _message__.criteriaNetwork,
        __reportNet = _message__.reportNet,
        __reportInterval = _message__.reportInterval,
        __runEveryMs = _message__.runEveryMs,
        __concurrentSubsteps = _message__.concurrentSubsteps,
        __shouldStopBlob = _message__.shouldStopBlob,
        __onlyOnce = _message__.onlyOnce,
        __createWorkspace = _message__.createWorkspace,
        __numConcurrentInstances = _message__.numConcurrentInstances,
        `_unknownFields__` = new _root_.scalapb.UnknownFieldSet.Builder(_message__.unknownFields)
    )
  }
  def newBuilder: Builder = caffe2.caffe2.ExecutionStep.Builder()
  def newBuilder(`_message__`: caffe2.caffe2.ExecutionStep): Builder = caffe2.caffe2.ExecutionStep.Builder(_message__)
  implicit class ExecutionStepLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, caffe2.caffe2.ExecutionStep]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, caffe2.caffe2.ExecutionStep](_l) {
    def name: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getName)((c_, f_) => c_.copy(name = Option(f_)))
    def optionalName: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.name)((c_, f_) => c_.copy(name = f_))
    def substep: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[caffe2.caffe2.ExecutionStep]] = field(_.substep)((c_, f_) => c_.copy(substep = f_))
    def network: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[_root_.scala.Predef.String]] = field(_.network)((c_, f_) => c_.copy(network = f_))
    def numIter: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getNumIter)((c_, f_) => c_.copy(numIter = Option(f_)))
    def optionalNumIter: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.numIter)((c_, f_) => c_.copy(numIter = f_))
    def criteriaNetwork: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getCriteriaNetwork)((c_, f_) => c_.copy(criteriaNetwork = Option(f_)))
    def optionalCriteriaNetwork: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.criteriaNetwork)((c_, f_) => c_.copy(criteriaNetwork = f_))
    def reportNet: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getReportNet)((c_, f_) => c_.copy(reportNet = Option(f_)))
    def optionalReportNet: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.reportNet)((c_, f_) => c_.copy(reportNet = f_))
    def reportInterval: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getReportInterval)((c_, f_) => c_.copy(reportInterval = Option(f_)))
    def optionalReportInterval: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.reportInterval)((c_, f_) => c_.copy(reportInterval = f_))
    def runEveryMs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getRunEveryMs)((c_, f_) => c_.copy(runEveryMs = Option(f_)))
    def optionalRunEveryMs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.runEveryMs)((c_, f_) => c_.copy(runEveryMs = f_))
    def concurrentSubsteps: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.getConcurrentSubsteps)((c_, f_) => c_.copy(concurrentSubsteps = Option(f_)))
    def optionalConcurrentSubsteps: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Boolean]] = field(_.concurrentSubsteps)((c_, f_) => c_.copy(concurrentSubsteps = f_))
    def shouldStopBlob: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getShouldStopBlob)((c_, f_) => c_.copy(shouldStopBlob = Option(f_)))
    def optionalShouldStopBlob: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.shouldStopBlob)((c_, f_) => c_.copy(shouldStopBlob = f_))
    def onlyOnce: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.getOnlyOnce)((c_, f_) => c_.copy(onlyOnce = Option(f_)))
    def optionalOnlyOnce: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Boolean]] = field(_.onlyOnce)((c_, f_) => c_.copy(onlyOnce = f_))
    def createWorkspace: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.getCreateWorkspace)((c_, f_) => c_.copy(createWorkspace = Option(f_)))
    def optionalCreateWorkspace: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Boolean]] = field(_.createWorkspace)((c_, f_) => c_.copy(createWorkspace = f_))
    def numConcurrentInstances: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getNumConcurrentInstances)((c_, f_) => c_.copy(numConcurrentInstances = Option(f_)))
    def optionalNumConcurrentInstances: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.numConcurrentInstances)((c_, f_) => c_.copy(numConcurrentInstances = f_))
  }
  final val NAME_FIELD_NUMBER = 1
  final val SUBSTEP_FIELD_NUMBER = 2
  final val NETWORK_FIELD_NUMBER = 3
  final val NUM_ITER_FIELD_NUMBER = 4
  final val CRITERIA_NETWORK_FIELD_NUMBER = 5
  final val REPORT_NET_FIELD_NUMBER = 7
  final val REPORT_INTERVAL_FIELD_NUMBER = 8
  final val RUN_EVERY_MS_FIELD_NUMBER = 11
  final val CONCURRENT_SUBSTEPS_FIELD_NUMBER = 6
  final val SHOULD_STOP_BLOB_FIELD_NUMBER = 9
  final val ONLY_ONCE_FIELD_NUMBER = 10
  final val CREATE_WORKSPACE_FIELD_NUMBER = 12
  final val NUM_CONCURRENT_INSTANCES_FIELD_NUMBER = 13
  def of(
    name: _root_.scala.Option[_root_.scala.Predef.String],
    substep: _root_.scala.Seq[caffe2.caffe2.ExecutionStep],
    network: _root_.scala.Seq[_root_.scala.Predef.String],
    numIter: _root_.scala.Option[_root_.scala.Long],
    criteriaNetwork: _root_.scala.Option[_root_.scala.Predef.String],
    reportNet: _root_.scala.Option[_root_.scala.Predef.String],
    reportInterval: _root_.scala.Option[_root_.scala.Int],
    runEveryMs: _root_.scala.Option[_root_.scala.Long],
    concurrentSubsteps: _root_.scala.Option[_root_.scala.Boolean],
    shouldStopBlob: _root_.scala.Option[_root_.scala.Predef.String],
    onlyOnce: _root_.scala.Option[_root_.scala.Boolean],
    createWorkspace: _root_.scala.Option[_root_.scala.Boolean],
    numConcurrentInstances: _root_.scala.Option[_root_.scala.Int]
  ): _root_.caffe2.caffe2.ExecutionStep = _root_.caffe2.caffe2.ExecutionStep(
    name,
    substep,
    network,
    numIter,
    criteriaNetwork,
    reportNet,
    reportInterval,
    runEveryMs,
    concurrentSubsteps,
    shouldStopBlob,
    onlyOnce,
    createWorkspace,
    numConcurrentInstances
  )
  // @@protoc_insertion_point(GeneratedMessageCompanion[caffe2.ExecutionStep])
}
